{"version":3,"file":"main-84208dbdf311aab.js","mappings":"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","sources":["webpack://russia-history/./@nextgis/packages/dialog/src/dialog.ts","webpack://russia-history/./@nextgis/packages/dialog/src/index.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/utils/imageIcons.ts","webpack://russia-history/./@nextgis/packages/utils/src/geom/eachCoordinates.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/utils/getCentroid.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/utils/convertZoomLevel.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/utils/convertMapClickEvent.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/utils/geomType.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/utils/getFeaturePosition.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/layer-adapters/BaseAdapter.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/layer-adapters/VectorAdapter.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/utils/makeHtmlFromString.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/layer-adapters/GeoJsonAdapter.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/utils/setupLayerTransformRequest.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/layer-adapters/BaseRasterAdapter.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/layer-adapters/TileAdapter.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/layer-adapters/MvtAdapter.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/layer-adapters/OsmAdapter.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/controls/createControl.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/utils/arrayToBoundsLike.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/MapboxglMapAdapter.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/controls/createButtonControl.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/layer-adapters/WmsAdapter.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/controls/ZoomControl.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/controls/CompassControl.ts","webpack://russia-history/./@nextgis/packages/mapboxgl-map-adapter/src/index.ts","webpack://russia-history/./@nextgis/packages/ngw-connector/src/errors/NetworkError.ts","webpack://russia-history/./@nextgis/packages/ngw-connector/src/errors/NgwError.ts","webpack://russia-history/./@nextgis/packages/ngw-connector/src/utils/loadData.ts","webpack://russia-history/./@nextgis/packages/ngw-connector/src/utils/template.ts","webpack://russia-history/./@nextgis/packages/ngw-connector/src/errors/ResourceNotFoundError.ts","webpack://russia-history/./@nextgis/packages/ngw-connector/src/errors/InsufficientPermissionsError.ts","webpack://russia-history/./@nextgis/packages/ngw-connector/src/activeConnectors.ts","webpack://russia-history/./@nextgis/packages/ngw-connector/src/utils/isObject.ts","webpack://russia-history/./@nextgis/packages/ngw-connector/src/utils/resourceToQuery.ts","webpack://russia-history/./@nextgis/packages/ngw-connector/src/ResourcesControl.ts","webpack://russia-history/./@nextgis/packages/ngw-connector/src/utils/resourceCompare.ts","webpack://russia-history/./@nextgis/packages/ngw-connector/src/NgwConnector.ts","webpack://russia-history/./@nextgis/packages/ngw-connector/src/utils/apiRequest.ts","webpack://russia-history/./@nextgis/packages/ngw-connector/src/index.ts","webpack://russia-history/./@nextgis/packages/paint/src/typeHelpers.ts","webpack://russia-history/./@nextgis/packages/paint/src/fromPaintExpression.ts","webpack://russia-history/./@nextgis/packages/paint/src/preparePaint.ts","webpack://russia-history/./@nextgis/packages/properties-filter/src/propertiesFilter.ts","webpack://russia-history/./@nextgis/packages/utils/src/applyMixins.ts","webpack://russia-history/./@nextgis/packages/qms-kit/src/utils/updateQmsOptions.ts","webpack://russia-history/./@nextgis/packages/qms-kit/src/utils/loadJson.ts","webpack://russia-history/./@nextgis/packages/qms-kit/src/utils/getSubmodulesFromOriginUrl.ts","webpack://russia-history/./@nextgis/packages/qms-kit/src/utils/createQmsAdapter.ts","webpack://russia-history/./@nextgis/packages/qms-kit/src/QmsKit.ts","webpack://russia-history/./@nextgis/packages/url-runtime-params/src/index.ts","webpack://russia-history/./@nextgis/packages/url-runtime-params/src/UrlRuntimeParams.ts","webpack://russia-history/./@nextgis/packages/utils/src/array/arrayUnique.ts","webpack://russia-history/./@nextgis/packages/utils/src/debounce.ts","webpack://russia-history/./@nextgis/packages/utils/src/defined.ts","webpack://russia-history/./@nextgis/packages/utils/src/events.ts","webpack://russia-history/./@nextgis/packages/utils/src/object/objectDeepEqual.ts","webpack://russia-history/./@nextgis/packages/utils/src/object/objectRemoveEmpty.ts","webpack://russia-history/./@nextgis/packages/utils/src/string/numberWithSpaces.ts","webpack://russia-history/./@nextgis/packages/utils/src/url.ts","webpack://russia-history/./@nextgis/packages/webmap/src/utils/geometryTypes.ts","webpack://russia-history/./@nextgis/packages/webmap/src/utils/updateGeoJsonAdapterOptions.ts","webpack://russia-history/./@nextgis/packages/utils/src/deepmerge.ts","webpack://russia-history/./@nextgis/packages/utils/src/geom/getBoundsPolygon.ts","webpack://russia-history/./@nextgis/packages/webmap/src/components/keys/KeysCodes.ts","webpack://russia-history/./@nextgis/packages/webmap/src/components/mapStates/StateItem.ts","webpack://russia-history/./@nextgis/packages/webmap/src/components/mapStates/CenterState.ts","webpack://russia-history/./@nextgis/packages/webmap/src/components/mapStates/ZoomState.ts","webpack://russia-history/./@nextgis/packages/webmap/src/WebMapMain.ts","webpack://russia-history/./@nextgis/packages/webmap/src/utils/clearObject.ts","webpack://russia-history/./@nextgis/packages/utils/src/deprecated/deprecatedMapClick.ts","webpack://russia-history/./@nextgis/packages/webmap/src/components/keys/Keys.ts","webpack://russia-history/./@nextgis/packages/webmap/src/WebMapLayers.ts","webpack://russia-history/./@nextgis/packages/webmap/src/WebMapControls.ts","webpack://russia-history/./@nextgis/packages/webmap/src/components/controls/createToggleControl.ts","webpack://russia-history/./@nextgis/packages/webmap/src/container.ts","webpack://russia-history/./@nextgis/packages/webmap/src/WebMap.ts"],"sourcesContent":["import 'dialog-polyfill/dialog-polyfill.css';\nimport dialogPolyfill from 'dialog-polyfill';\nimport { DialogAdapter, DialogAdapterOptions } from './interfaces';\n\nimport './dialog.css';\n\nconst closeBtn = `\n  <a href=\"#\">\n    <svg height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\">\n      <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\">\n      </path>\n      <path d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    </svg>\n  </a>\n`;\n\nexport class Dialog implements DialogAdapter {\n  static dialogs: Dialog[] = [];\n  options: DialogAdapterOptions = {\n    template: `\n      <p>This is dialog!</p>\n    `,\n    closeBtn: true,\n    closeBtnTemplate: closeBtn,\n  };\n  // TODO: rewrite this component for no browser dialog HTMLDialogElement because is deprecated\n  private _dialog: any;\n  private _isNativeDialog: boolean;\n  private _content: HTMLElement;\n  private _parent: Node;\n  private _closeBtn?: HTMLElement;\n\n  constructor(options?: DialogAdapterOptions) {\n    this._dialog = document.createElement('dialog') as HTMLDialogElement;\n\n    Dialog.dialogs.push(this);\n\n    this._dialog.className = 'dialog-component';\n    this.options = { ...this.options, ...options };\n    this._parent = this.options.parent || document.body;\n\n    this._isNativeDialog = !!this._dialog.showModal;\n\n    if (!this._isNativeDialog) {\n      dialogPolyfill.registerDialog(this._dialog);\n      this._dialog.classList.add('polyfilled');\n    }\n\n    if (this.options.closeBtn) {\n      this._closeBtn = this._createCloseBtn();\n    }\n\n    this._content = document.createElement('div');\n    this._dialog.appendChild(this._content);\n\n    this.updateContent();\n\n    if (this._parent) {\n      this._parent.appendChild(this._dialog);\n    }\n\n    this._addEventsListeners();\n  }\n\n  static clean(): void {\n    Dialog.dialogs.forEach((x) => x.destroy());\n  }\n\n  getContainer(): HTMLDialogElement {\n    return this._dialog;\n  }\n\n  show(): void {\n    this._dialog.showModal();\n  }\n\n  close(): void {\n    this._dialog.close();\n  }\n\n  destroy(): void {\n    this.close();\n    this._dialog.remove();\n  }\n\n  updateContent(content?: string | Node): void {\n    if (!content && this.options.template) {\n      content = this.options.template;\n    }\n    if (content) {\n      this._addContent(content, this._content);\n    }\n  }\n\n  private _createCloseBtn() {\n    const template = this.options.closeBtnTemplate;\n    if (template) {\n      const btn = document.createElement('div');\n      btn.className = 'dialog-component__close';\n      this._dialog.appendChild(btn);\n      this._addContent(template, btn);\n\n      btn.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.close();\n      });\n      return btn;\n    }\n  }\n\n  private _addContent(content: string | Node, parent: HTMLElement) {\n    if (typeof content === 'string') {\n      parent.innerHTML = content;\n    } else if (content instanceof HTMLElement) {\n      parent.innerHTML = '';\n      parent.appendChild(content);\n    }\n  }\n\n  private _addEventsListeners() {\n    if (this._closeBtn) {\n      this._closeBtn.addEventListener('click', (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        this.close();\n      });\n    }\n    if (this.options.openers) {\n      [].forEach.call(this.options.openers, (opener: HTMLElement) => {\n        opener.onclick = (e) => {\n          e.preventDefault();\n          this.show();\n        };\n      });\n    }\n\n    this._dialog.addEventListener('close', () => {\n      // console.log('dialog closed');\n    });\n    this._dialog.addEventListener('cancel', () => {\n      // console.log('dialog canceled');\n    });\n  }\n}\n","/**\n * @module dialog\n */\n\nimport { Dialog } from './dialog';\nimport { DialogAdapterOptions } from './interfaces';\n\nexport type { DialogAdapterOptions };\n\nexport default Dialog;\n","let canvg: any;\ntry {\n  canvg = require('canvg');\n} catch (er) {\n  // ignore\n}\ninterface GetImgOpt {\n  width: number;\n  height: number;\n  x?: number;\n  y?: number;\n  sdf?: string;\n  pixelRatio?: number;\n}\n\n// const defAddImgOpt = {\n//   width: 12,\n//   height: 12,\n//   x: 0,\n//   y: 0,\n//   sdf: undefined,\n//   pixelRatio: 2\n// };\n\n// // from /mapbox-gl/src/util/browser.js\nexport function getImageData(\n  img: string | HTMLImageElement,\n  opt: GetImgOpt,\n): ImageData {\n  const canvas = window.document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  if (!context) {\n    throw new Error('failed to create canvas 2d context');\n  }\n  canvas.setAttribute('width', String(opt.width));\n  canvas.setAttribute('height', String(opt.height));\n  if (!canvg && img instanceof HTMLImageElement) {\n    context.drawImage(img, 0, 0, opt.width, opt.height);\n  } else if (typeof img === 'string') {\n    if (canvg.Canvg) {\n      // for canvg v.3.x.x\n      const v = canvg.Canvg.fromString(context, img);\n      v.start();\n    } else {\n      // for canvg v.2.x.x\n      canvg(canvas, img);\n    }\n  }\n  return context.getImageData(0, 0, opt.width, opt.height);\n}\n\nexport function getImage(svgStr: string, opt: GetImgOpt): Promise<ImageData> {\n  return new Promise((resolve) => {\n    if (canvg) {\n      resolve(getImageData(svgStr, opt));\n    } else {\n      const svgImage = new Image();\n      svgImage.crossOrigin = 'Anonymous';\n      svgImage.src = 'data:image/svg+xml;base64,' + btoa(svgStr);\n\n      svgImage.onload = () => {\n        const imageData = getImageData(svgImage, opt);\n        resolve(imageData);\n      };\n    }\n  });\n}\n","import type { GeoJSON, Position, Geometry } from 'geojson';\n\nexport function coordinatesCount(geojson: GeoJSON): number {\n  let count = 0;\n  eachCoordinates(geojson, () => count++);\n  return count;\n}\n\nexport function getCoordinates(geojson: GeoJSON): Position[] {\n  const coordinates: Position[] = [];\n  eachCoordinates(geojson, (pos) => coordinates.push(pos));\n  return coordinates;\n}\n\nexport function eachCoordinates(\n  geojson: GeoJSON,\n  cb: (position: Position) => void,\n): void {\n  eachGeometry(geojson, (geom) => {\n    if ('coordinates' in geom) {\n      if (geom.type === 'Polygon' || geom.type === 'MultiLineString') {\n        for (const x of geom.coordinates) {\n          x.forEach((y) => cb(y));\n        }\n      } else if (geom.type === 'MultiPolygon') {\n        for (const x of geom.coordinates) {\n          x.forEach((y) => y.forEach((z) => cb(z)));\n        }\n      } else if (geom.type === 'Point') {\n        cb(geom.coordinates);\n      } else if (geom.type === 'MultiPoint' || geom.type === 'LineString') {\n        for (const x of geom.coordinates) {\n          cb(x);\n        }\n      }\n    }\n    return geom;\n  });\n}\n\nexport function getPolygons(geojson: GeoJSON): Position[][] {\n  const polygons: Position[][] = [];\n  eachGeometry(geojson, (geom) => {\n    if ('coordinates' in geom) {\n      if (geom.type === 'Polygon') {\n        geom.coordinates.forEach((x) => polygons.push(x));\n      } else if (geom.type === 'MultiPolygon') {\n        for (const x of geom.coordinates) {\n          for (const y of x) {\n            polygons.push(y);\n          }\n        }\n      }\n    }\n    return geom;\n  });\n  return polygons;\n}\n\nexport function eachGeometry(\n  geojson: GeoJSON,\n  cb: (position: Geometry) => void,\n): void {\n  if (geojson.type === 'FeatureCollection') {\n    for (const f of geojson.features) {\n      cb(f.geometry);\n    }\n  } else if (geojson.type === 'Feature') {\n    cb(geojson.geometry);\n  } else if ('coordinates' in geojson) {\n    cb(geojson);\n  }\n}\n","import polylabel from 'polylabel';\nimport { getCoordinates } from '@nextgis/utils';\n\nimport type { Feature } from 'geojson';\n\nexport function getCentroid(feature: Feature): number[] {\n  if (feature.geometry.type === 'Polygon') {\n    return polylabel(feature.geometry.coordinates);\n  } else if (feature.geometry.type === 'Point') {\n    return feature.geometry.coordinates;\n  }\n  return getCoordinatesCentroid(getCoordinates(feature));\n}\n\n// https://stackoverflow.com/a/22796806\nfunction getCoordinatesCentroid(arr: number[][]) {\n  return arr.reduce(\n    (x, y) => {\n      return [x[0] + y[0] / arr.length, x[1] + y[1] / arr.length];\n    },\n    [0, 0],\n  );\n}\n","export function convertZoomLevel(zoom: number) {\n  return zoom - 1;\n}\n","import type { MapClickEvent } from '@nextgis/webmap';\nimport type { MapMouseEvent, MapEventType } from 'maplibre-gl';\n\nexport function convertMapClickEvent(\n  evt: MapEventType['click'] & MapMouseEvent,\n): MapClickEvent {\n  const latLng = evt.lngLat;\n  const { lng, lat } = latLng;\n  const { x, y } = evt.point;\n  return {\n    latLng,\n    lngLat: [lng, lat],\n    pixel: { top: y, left: x },\n  };\n}\n","import {\n  GeoJsonGeometryTypes,\n  GeoJsonObject,\n  FeatureCollection,\n  Feature,\n  GeometryCollection,\n} from 'geojson';\nimport { VectorAdapterLayerType } from '@nextgis/webmap';\n\nexport const allowedParams: ([string, string] | string)[] = [\n  'color',\n  'opacity',\n];\nexport const allowedByType: {\n  [key in VectorAdapterLayerType]: ([string, string] | string)[];\n} = {\n  point: [\n    ['color', 'color'],\n    ['fillColor', 'color'],\n    ['opacity', 'opacity'],\n    ['fillOpacity', 'opacity'],\n    ['strokeColor', 'stroke-color'],\n    ['strokeOpacity', 'stroke-opacity'],\n    ['weight', 'stroke-width'],\n    'radius',\n  ],\n  line: [\n    ['color', 'color'],\n    ['strokeColor', 'color'],\n    ['opacity', 'opacity'],\n    ['strokeOpacity', 'opacity'],\n    ['weight', 'width'],\n  ],\n  polygon: [\n    ['color', 'color'],\n    ['fillColor', 'color'],\n    ['opacity', 'opacity'],\n    ['fillOpacity', 'opacity'],\n  ],\n};\n\nexport const typeAlias: {\n  [key in GeoJsonGeometryTypes]: VectorAdapterLayerType;\n} = {\n  Point: 'point',\n  LineString: 'line',\n  MultiPoint: 'point',\n  Polygon: 'polygon',\n  MultiLineString: 'line',\n  MultiPolygon: 'polygon',\n  GeometryCollection: 'polygon',\n};\n\nexport const typeAliasForFilter: {\n  [key in VectorAdapterLayerType]: GeoJsonGeometryTypes;\n} = {\n  point: 'Point',\n  line: 'LineString',\n  polygon: 'Polygon',\n};\n\nexport const backAliases: {\n  [key in VectorAdapterLayerType]?: GeoJsonGeometryTypes[];\n} = {};\n\nfor (const a in typeAlias) {\n  const layerType = typeAlias[a as GeoJsonGeometryTypes];\n  const backAlias = backAliases[layerType] || [];\n  backAlias.push(a as GeoJsonGeometryTypes);\n  backAliases[layerType] = backAlias;\n}\n\nexport function findMostFrequentGeomType(\n  arr: GeoJsonGeometryTypes[],\n): GeoJsonGeometryTypes {\n  const counts: { [x: string]: number } = {};\n  for (let fry = 0; fry < arr.length; fry++) {\n    counts[arr[fry]] = 1 + (counts[arr[fry]] || 0);\n  }\n  let maxName = '';\n  for (const c in counts) {\n    const maxCount = maxName ? counts[maxName] : 0;\n    if (counts[c] > maxCount) {\n      maxName = c;\n    }\n  }\n  return maxName as GeoJsonGeometryTypes;\n}\n\nexport function detectType(geojson: GeoJsonObject): GeoJsonGeometryTypes {\n  let geometry: GeoJsonGeometryTypes;\n  if (geojson.type === 'FeatureCollection') {\n    const featuresTypes = (geojson as FeatureCollection).features.map(\n      (f) => f.geometry.type,\n    );\n    geometry = findMostFrequentGeomType(featuresTypes);\n  } else if (geojson.type === 'GeometryCollection') {\n    const geometryTypes = (geojson as GeometryCollection).geometries.map(\n      (g) => g.type,\n    );\n    geometry = findMostFrequentGeomType(geometryTypes);\n  } else if (geojson.type === 'Feature') {\n    geometry = (geojson as Feature).geometry.type;\n  } else {\n    geometry = geojson.type;\n  }\n  return geometry;\n}\n\n// Static functions\nexport function geometryFilter(\n  geometry: GeoJsonGeometryTypes,\n  type: VectorAdapterLayerType,\n): boolean {\n  const backType = backAliases[type];\n  if (backType) {\n    return backType.indexOf(geometry) !== -1;\n  }\n  return false;\n}\n","import { LngLatBounds } from 'maplibre-gl';\nimport { getCoordinates } from '@nextgis/utils';\nimport type { Feature } from 'geojson';\nimport type { FeaturePosition } from '@nextgis/webmap';\nimport type { LngLatBoundsArray, LngLatArray } from '@nextgis/utils';\n\nfunction getFeatureLngLatBounds(\n  featureOrFeatures: Feature | Feature[],\n): LngLatBounds {\n  const bounds = new LngLatBounds();\n  const features = Array.isArray(featureOrFeatures)\n    ? featureOrFeatures\n    : [featureOrFeatures];\n  for (const feature of features) {\n    const coord = getCoordinates(feature);\n    for (const x of coord) {\n      bounds.extend(x as [number, number]);\n    }\n  }\n  return bounds;\n}\n\nexport function getFeatureBounds(\n  featureOrFeatures: Feature | Feature[],\n): LngLatBoundsArray {\n  const bounds = getFeatureLngLatBounds(featureOrFeatures);\n  const ne = bounds.getNorthEast();\n  const sw = bounds.getSouthWest();\n\n  return [sw.lng, sw.lat, ne.lng, ne.lat];\n}\n\nexport function getFeatureCenter(\n  featureOrFeatures: Feature | Feature[],\n): LngLatArray {\n  const bounds = getFeatureLngLatBounds(featureOrFeatures);\n  const { lng, lat } = bounds.getCenter();\n  return [lng, lat];\n}\n\nexport function createFeaturePositionOptions(\n  featureOrFeatures: Feature | Feature[],\n): FeaturePosition {\n  return {\n    getBounds: () => getFeatureBounds(featureOrFeatures),\n    getCenter: () => getFeatureCenter(featureOrFeatures),\n  };\n}\n","import { Map } from 'maplibre-gl';\nimport { MainLayerAdapter, AdapterOptions } from '@nextgis/webmap';\nimport { TLayer } from '../MapboxglMapAdapter';\n\nlet ID = 0;\n\nexport abstract class BaseAdapter<O extends AdapterOptions = AdapterOptions>\n  implements MainLayerAdapter<Map, TLayer, O>\n{\n  layer?: TLayer;\n  map?: Map;\n  protected readonly _layerId: string;\n\n  constructor(map: Map, public options: O) {\n    this.map = map;\n    this._layerId = `layer-${ID++}`;\n  }\n\n  beforeRemove(): void {\n    if (this.map) {\n      const sourceId = this._layerId + '_source';\n      const source = this.map.getSource(sourceId);\n      if (source) {\n        this.map.removeSource(sourceId);\n      }\n    }\n    Object.assign(this, { map: undefined });\n  }\n\n  abstract addLayer(options: O): TLayer | Promise<TLayer> | undefined;\n}\n","import { isPaint, isIcon, PathPaint, isPaintCallback } from '@nextgis/paint';\nimport { isPropertyFilter, featureFilter } from '@nextgis/properties-filter';\n\nimport { getImage } from '../utils/imageIcons';\nimport { getCentroid } from '../utils/getCentroid';\nimport { convertZoomLevel } from '../utils/convertZoomLevel';\nimport { makeHtmlFromString } from '../utils/makeHtmlFromString';\nimport { convertMapClickEvent } from '../utils/convertMapClickEvent';\nimport { typeAliasForFilter, allowedByType } from '../utils/geomType';\nimport { createFeaturePositionOptions } from '../utils/getFeaturePosition';\nimport { BaseAdapter } from './BaseAdapter';\n\nimport type {\n  GeoJsonProperties,\n  GeometryObject,\n  Feature as F,\n  Geometry,\n} from 'geojson';\nimport {\n  Map,\n  Popup,\n  Layout,\n  LngLatLike,\n  MapEventType,\n  MapMouseEvent,\n  LayerSpecification,\n  SourceSpecification,\n  MapLayerMouseEvent,\n  FilterSpecification,\n} from 'maplibre-gl';\nimport type { Paint, IconPaint } from '@nextgis/paint';\nimport type {\n  VectorAdapterLayerType,\n  PopupOnCloseFunction,\n  VectorAdapterOptions,\n  VectorLayerAdapter,\n  OnLayerSelectType,\n  DataLayerFilter,\n  LayerDefinition,\n  FilterOptions,\n  PopupOptions,\n} from '@nextgis/webmap';\nimport type { TLayer } from '../MapboxglMapAdapter';\nimport type {\n  PropertiesFilter,\n  PropertyFilter,\n  Operations,\n} from '@nextgis/properties-filter';\nimport type { VectorLayerSpecification } from '../interfaces';\n\ntype Layer = VectorLayerSpecification;\n\nexport const operationsAliases: { [key in Operations]: string } = {\n  gt: '>',\n  lt: '<',\n  ge: '>=',\n  le: '<=',\n  eq: '==',\n  ne: '!=',\n  in: 'in',\n  notin: '!in',\n  // NOT SUPPORTED\n  like: '==',\n  // NOT SUPPORTED\n  ilike: '==',\n};\n\nconst reversOperations: { [key in Operations]: string } = {\n  gt: operationsAliases.le,\n  lt: operationsAliases.ge,\n  ge: operationsAliases.lt,\n  le: operationsAliases.gt,\n  eq: operationsAliases.ne,\n  ne: operationsAliases.eq,\n  in: operationsAliases.notin,\n  notin: operationsAliases.in,\n  like: operationsAliases.ne,\n  ilike: operationsAliases.ne,\n};\n\nexport interface EventOptions {\n  silent?: boolean;\n}\n\nexport interface Feature<\n  G extends GeometryObject | null = Geometry,\n  P = GeoJsonProperties,\n> extends F<G, P> {\n  _featureFilterId?: string;\n}\n\nconst PAINT = {\n  color: 'blue',\n  opacity: 1,\n  radius: 10,\n};\n\ntype MapboxLayerType = 'fill' | 'line' | 'symbol' | 'circle';\n\nconst mapboxTypeAlias: Record<VectorAdapterLayerType, MapboxLayerType> = {\n  polygon: 'fill',\n  line: 'line',\n  point: 'circle',\n};\n\nexport abstract class VectorAdapter<\n    O extends VectorAdapterOptions = VectorAdapterOptions,\n  >\n  extends BaseAdapter<O>\n  implements VectorLayerAdapter<Map, TLayer, O, Feature>\n{\n  selected = false;\n  map?: Map;\n  protected featureIdName = 'id';\n  protected _types: VectorAdapterLayerType[] = ['polygon', 'point', 'line'];\n  protected readonly _sourceId: string;\n  protected readonly _selectionName: string;\n  protected _selectedFeatureIds: (number | string)[] | false = [];\n\n  protected _selectProperties?: PropertiesFilter;\n  protected _filterProperties?: PropertiesFilter;\n  protected _openedPopup: [Feature, Popup, PopupOnCloseFunction[]][] = [];\n\n  private $onLayerMouseMove?: (e: MapLayerMouseEvent) => void;\n  private $onLayerMouseLeave?: (e: MapLayerMouseEvent) => void;\n\n  constructor(map: Map, public options: O) {\n    super(map, options);\n    this._sourceId = this.options.source\n      ? (this.options.source as string)\n      : `source-${this._layerId}`;\n\n    if (this.options.featureIdName) {\n      this.featureIdName = this.options.featureIdName;\n    } else if (this.options.source) {\n      this.featureIdName = '$id';\n    } else {\n      this.featureIdName = 'fid';\n    }\n\n    this._selectionName = this._layerId + '-highlighted';\n    this.$onLayerMouseLeave = this._onLayerMouseLeave.bind(this);\n    this.$onLayerMouseMove = this._onLayerMouseMove.bind(this);\n    map._onMapClickLayers.push(this);\n  }\n\n  async addLayer(options: O): Promise<TLayer> {\n    options = this.options = { ...this.options, ...(options || {}) };\n    if (options.featureIdName) {\n      this.featureIdName = options.featureIdName;\n    }\n\n    this.layer = [];\n    const types = (this._types = options.type ? [options.type] : this._types);\n    if (options.paint) {\n      this._beforeLayerLayer(this._sourceId);\n      for (const t of types) {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          let type = t;\n          if (t === 'point') {\n            const paintType = this._detectPaintType(options.paint);\n            if (paintType === 'icon') {\n              type = 'point';\n            }\n          }\n          const layer = this._getLayerNameFromType(t);\n          const geomFilter =\n            types.length > 1 ? ['==', '$type', geomType] : undefined;\n\n          await this._addGeomLayer(layer, type, [\n            geomFilter,\n            this._getNativeFilter(),\n          ]);\n          this.layer.push(layer);\n          if (options.selectedPaint) {\n            const selectionLayer = this._getSelectionLayerNameFromType(t);\n            await this._addGeomLayer(\n              selectionLayer,\n              type,\n              [geomFilter, ['in', this.featureIdName, '']],\n              this.options.selectedLayout,\n            );\n            this.layer.push(selectionLayer);\n          }\n        }\n      }\n      await this._onLayerAdd(this._sourceId);\n    }\n\n    this._addEventsListeners();\n\n    return this.layer;\n  }\n\n  propertiesFilter(filters: PropertiesFilter, options?: FilterOptions): void {\n    this._filterProperties = filters;\n    this._updatePropertiesFilter();\n  }\n\n  removeFilter(): void {\n    this._filterProperties = undefined;\n    this._updateFilter();\n  }\n\n  select(properties?: DataLayerFilter<F, TLayer> | PropertiesFilter): void {\n    if (typeof properties !== 'function') {\n      this._selectProperties = properties;\n      this._updateFilter();\n    }\n    this.selected = true;\n    const { onSelect, onLayerSelect } = this.options;\n    const onSelect_ = onSelect || onLayerSelect;\n    if (onSelect_) {\n      const features: Feature[] = [];\n      onSelect_({\n        layer: this,\n        features,\n        type: 'api',\n        ...createFeaturePositionOptions(features),\n      });\n    }\n  }\n\n  unselect(): void {\n    if (this.options.selectable) {\n      this._selectProperties = undefined;\n      this._updateFilter();\n      this.selected = false;\n      const { onSelect, onLayerSelect } = this.options;\n      const onSelect_ = onSelect || onLayerSelect;\n      if (onSelect_) {\n        onSelect_({\n          layer: this,\n          features: undefined,\n          type: 'api',\n          ...createFeaturePositionOptions([]),\n        });\n      }\n      this._removeAllPopup();\n    }\n  }\n\n  beforeRemove(): void {\n    const map = this.map;\n    if (map) {\n      if (this.layer) {\n        this.layer.forEach((layerId) => {\n          map.removeLayer(layerId);\n        });\n      }\n      const index = map._onMapClickLayers.indexOf(this);\n      if (index !== -1) {\n        map._onMapClickLayers.splice(index, 1);\n      }\n    }\n    this._removeAllPopup();\n    this._removeEventListeners();\n    this.$onLayerMouseLeave = undefined;\n    this.$onLayerMouseMove = undefined;\n    super.beforeRemove();\n  }\n\n  setOpacity(val: number): void {\n    this.options.opacity = Number(val);\n    if (this.options.type) {\n      this._updateLayerPaint(this.options.type);\n    }\n  }\n\n  setPaint(paint?: Paint | null): void {\n    if (paint) {\n      this.options.paint = paint;\n      if (this.options.type) {\n        this._updateLayerPaint(this.options.type);\n      }\n    }\n  }\n  setSelectedPaint(paint?: Paint | null): void {\n    if (paint) {\n      this.options.selectedPaint = paint;\n      if (this.options.type) {\n        this._updateLayerPaint(this.options.type);\n      }\n    }\n  }\n  updatePaint(paint: Partial<Paint>): void {\n    this.options.paint = { ...this.options.paint, ...paint } as Paint;\n    if (this.options.type) {\n      this._updateLayerPaint(this.options.type);\n    }\n  }\n  updateSelectedPaint(paint: Partial<Paint>): void {\n    this.options.selectedPaint = {\n      ...this.options.selectedPaint,\n      ...paint,\n    } as Paint;\n    if (this.options.type) {\n      this._updateLayerPaint(this.options.type);\n    }\n  }\n\n  _onLayerClick(\n    e: MapLayerMouseEvent,\n  ): Feature<Geometry, GeoJsonProperties> | undefined {\n    e.preventDefault();\n    let feature: Feature | undefined;\n    const map = this.map;\n    if (!map) {\n      return;\n    }\n    if (this.layer) {\n      feature = this._getFeatureFromPoint(e);\n      if (feature) {\n        const isSelected = this._featureSelect(feature, e.lngLat);\n        if (this.options.onClick) {\n          this.options.onClick({\n            layer: this,\n            selected: isSelected,\n            event: convertMapClickEvent(e),\n            source: e,\n            ...this._createLayerOptions(feature),\n          });\n        }\n      }\n    }\n    return feature;\n  }\n\n  protected _featureSelect(\n    feature: Feature,\n    coordinates?: LngLatLike,\n  ): boolean {\n    const alreadySelected = this.isFeatureSelected(feature);\n    let becameSelected = alreadySelected;\n\n    if (this.options.selectable) {\n      let features: Feature[] | undefined = undefined;\n      if (alreadySelected) {\n        if (this.options && this.options.unselectOnSecondClick) {\n          this._unselectFeature(feature, { silent: true });\n          becameSelected = false;\n        }\n      } else {\n        this.map &&\n          this.map._addUnselectCb(() =>\n            this._unselectFeature(feature, { silent: true }),\n          );\n        features = this._selectFeature(feature, { silent: true });\n        becameSelected = true;\n      }\n      // alreadySelected = this.isFeatureSelected(feature);\n      if (this.options.onSelect) {\n        this.options.onSelect({\n          layer: this,\n          features,\n          type: 'click',\n          ...createFeaturePositionOptions(feature),\n        });\n      }\n    }\n    if (becameSelected && this.options.popupOnSelect) {\n      this._openPopup({\n        coordinates,\n        feature,\n        options: this.options.popupOptions,\n        type: 'click',\n        refresh: true,\n      });\n    }\n    this.selected = becameSelected;\n    return this.selected;\n  }\n\n  protected _updateWithNativeFilter(filter: any[]): any[] {\n    const nativeFilter = this._getNativeFilter();\n    if (nativeFilter.length) {\n      filter.push(nativeFilter);\n    }\n    return filter;\n  }\n\n  protected _getNativeFilter(): PropertyFilter {\n    return (\n      this.options.nativeFilter ? this.options.nativeFilter : []\n    ) as PropertyFilter;\n  }\n\n  protected async _addGeomLayer(\n    name: string,\n    type: VectorAdapterLayerType,\n    filter?: any[],\n    layout?: Layout<any>,\n  ): Promise<void> {\n    let mType: MapboxLayerType | undefined;\n    if (this.options.paint) {\n      if ('type' in this.options.paint && this.options.paint.type === 'icon') {\n        mType = 'symbol';\n      }\n    }\n    if (mType === undefined) {\n      mType = mapboxTypeAlias[type];\n    }\n    layout = (layout || this.options.layout || {}) as Layout<any>;\n    const layerOpt: Layer = {\n      id: name,\n      type: mType,\n      source: this._sourceId,\n      filter,\n      layout: {\n        visibility: 'none',\n        ...layout,\n      },\n      ...this._getAdditionalLayerOptions(),\n    };\n    if (this.options.nativeOptions) {\n      Object.assign(layerOpt, this.options.nativeOptions);\n    }\n    this._addLayer(layerOpt);\n  }\n\n  protected _addLayer(layerOpt: Layer): void {\n    const { filter, ...opt } = layerOpt;\n    const { minZoom, maxZoom } = this.options;\n    if (minZoom) {\n      opt.minzoom = convertZoomLevel(minZoom);\n    }\n    if (maxZoom) {\n      opt.maxzoom = convertZoomLevel(maxZoom);\n    }\n    const map = this.map;\n    if (map) {\n      map.addLayer(opt as LayerSpecification);\n      if (filter) {\n        const filters = ['all', ...(filter || [])].filter(Boolean);\n        map.setFilter(opt.id, filters as FilterSpecification);\n      }\n    }\n  }\n\n  protected async _beforeLayerLayer(\n    sourceId: string,\n    options?: SourceSpecification,\n  ): Promise<void> {\n    // ignore\n  }\n  protected async _onLayerAdd(\n    sourceId: string,\n    options?: SourceSpecification,\n  ): Promise<void> {\n    // ignore\n  }\n\n  protected async _updateLayerPaint(\n    type: VectorAdapterLayerType,\n  ): Promise<void> {\n    const layerName = this._getLayerNameFromType(type);\n\n    if (this.options.paint) {\n      const layers: [string, Paint][] = [[layerName, this.options.paint]];\n      if (this.options.selectedPaint) {\n        const selName = this._getSelectionLayerNameFromType(type);\n        layers.push([selName, this.options.selectedPaint]);\n      }\n\n      const mapboxType = mapboxTypeAlias[type];\n      for (const [name, paint] of layers) {\n        let _paint: any;\n        let nativePaint: Record<string, any> | null = null;\n        let typePaint = null;\n        if (this.options.nativePaint) {\n          nativePaint =\n            typeof this.options.nativePaint === 'boolean'\n              ? paint\n              : this.options.nativePaint;\n          const opacity = this.options.opacity;\n          if (opacity !== undefined && nativePaint) {\n            const allowedNativePaint = allowedByType[type]\n            const opacityProp = allowedNativePaint.find((x) => x[0] === 'opacity');\n            if (opacityProp) {\n              nativePaint[mapboxType + '-' + opacityProp[1]]\n            }\n            for (const p in nativePaint) {\n              if (p.indexOf('opacity') !== -1) {\n                nativePaint[p] = opacity;\n              }\n            }\n          }\n        } else {\n          typePaint = await this._createPaintForType(paint, type, name);\n        }\n        _paint = typePaint || nativePaint;\n        if (this.map) {\n          if ('icon-image' in _paint) {\n            // If true, the icon will be visible even if it collides with other previously drawn symbols.\n            _paint['icon-allow-overlap'] = true;\n            for (const p in _paint) {\n              try {\n                this.map.setLayoutProperty(name, p, _paint[p]);\n              } catch (er) {\n                //\n              }\n            }\n          } else {\n            for (const p in _paint) {\n              this.map.setPaintProperty(name, p, _paint[p]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  protected _getLayerNameFromType(type: string): string {\n    return type + '-' + this._layerId;\n  }\n\n  protected _getSelectionLayerNameFromType(\n    type: VectorAdapterLayerType,\n  ): string {\n    return type + '-' + this._selectionName;\n  }\n\n  protected async _createPaintForType(\n    paint: Paint,\n    type: VectorAdapterLayerType,\n    name?: string,\n  ): Promise<any> {\n    if (isPaint(paint)) {\n      const mapboxPaint: any = {};\n      const paint_ = { ...PAINT, ...(paint || {}) };\n      if (paint.type === 'icon' && paint.html) {\n        await this._registerImage(paint);\n        return {\n          'icon-image': paint.html,\n        };\n      } else {\n        const pathPaint = paint_ as PathPaint;\n        const mapboxType = mapboxTypeAlias[type];\n        const allowed = allowedByType[type];\n        if (allowed) {\n          let p: keyof typeof pathPaint;\n          for (p in pathPaint) {\n            // Special case for strokeColor\n            const polyStroke = type === 'polygon' && p === 'strokeColor';\n            if (polyStroke && pathPaint.stroke) {\n              mapboxPaint['fill-outline-color'] = pathPaint[p];\n            }\n            if (!polyStroke) {\n              const allowedType = allowed.find((x) => {\n                if (typeof x === 'string') {\n                  return x === p;\n                } else if (Array.isArray(x)) {\n                  return x[0] === p;\n                }\n                return false;\n              });\n              if (allowedType) {\n                const paramName = Array.isArray(allowedType)\n                  ? allowedType[1]\n                  : allowedType;\n\n                const opacity = this.options.opacity;\n                let prop = pathPaint[p];\n                if (\n                  opacity !== undefined &&\n                  paramName.indexOf('opacity') !== -1\n                ) {\n                  prop = Number(prop) * opacity;\n                }\n\n                mapboxPaint[mapboxType + '-' + paramName] = prop;\n              }\n            }\n          }\n        }\n        mapboxPaint[mapboxType + '-opacity-transition'] = {\n          duration: 0,\n        };\n        return mapboxPaint;\n      }\n    } else if (isPaintCallback(paint) && paint.paint) {\n      return this._createPaintForType(paint.paint, type);\n    }\n  }\n\n  protected _getFeatureFilterId(feature: Feature): string | number | undefined {\n    const id = feature._featureFilterId;\n    if (id !== undefined) {\n      return id;\n    } else if (\n      feature.properties &&\n      feature.properties[this.featureIdName] !== undefined\n    ) {\n      return feature.properties[this.featureIdName];\n    }\n    return feature.id;\n  }\n\n  protected async _registerImage(paint: IconPaint): Promise<void> {\n    if (isIcon(paint) && paint.html && this.map) {\n      const imageExist = this.map.hasImage(paint.html);\n      if (!imageExist) {\n        let width = 12;\n        let height = 12;\n        if (paint.iconSize) {\n          width = paint.iconSize[0];\n          height = paint.iconSize[1];\n        }\n        const image = await getImage(paint.html, {\n          width,\n          height,\n        });\n        if (this.map) {\n          this.map.addImage(paint.html, image);\n        }\n      }\n    }\n  }\n\n  protected _selectFeature(\n    feature: Feature | Feature[],\n    opt?: { silent: boolean },\n  ): Feature[] {\n    const features = Array.isArray(feature) ? feature : [feature];\n    this.select([\n      [\n        this.featureIdName,\n        'in',\n        features.map(\n          (x) => (x.properties && x.properties[this.featureIdName]) || x.id,\n        ),\n      ],\n    ]);\n    return [];\n  }\n\n  protected _unselectFeature(\n    feature: Feature | Feature[],\n    opt?: { silent: boolean },\n  ): void {\n    // ignore\n  }\n\n  protected _getAdditionalLayerOptions(): Record<string, unknown> {\n    return {};\n  }\n\n  protected _updateFilter(opt?: EventOptions): void {\n    this._updatePropertiesFilter();\n  }\n\n  protected _updatePropertiesFilter(): void {\n    const layers = this.layer;\n    if (layers) {\n      for (const t of this._types) {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          const geomFilter = ['==', '$type', geomType];\n          const layerName = this._getLayerNameFromType(t);\n          const selLayerName = this._getSelectionLayerNameFromType(t);\n          const selectProperties = this._selectProperties;\n          const filterProperties = this._filterProperties;\n          const propertyFilters =\n            filterProperties && this._convertToMapboxFilter(filterProperties);\n          if (this.map && layers.indexOf(selLayerName) !== -1) {\n            if (this._selectionName) {\n              let filters: any[] = [];\n              if (selectProperties || this._selectedFeatureIds) {\n                if (selectProperties) {\n                  filters = this._convertToMapboxFilter(selectProperties) || [];\n                } else if (this._selectedFeatureIds) {\n                  filters = [\n                    ['in', this.featureIdName, ...this._selectedFeatureIds],\n                  ];\n                }\n                if (propertyFilters) {\n                  propertyFilters.forEach((x) => filters.push(x));\n                }\n                this.map.setFilter(selLayerName, [\n                  'all',\n                  geomFilter,\n                  ...filters,\n                ]);\n              } else {\n                filters = ['in', '$id', ''];\n                this.map.setFilter(selLayerName, filters);\n              }\n            }\n          }\n          if (this.map && layers.indexOf(layerName) !== -1) {\n            const filters_: any[] = ['all', geomFilter];\n            this._updateWithNativeFilter(filters_);\n            if (selectProperties) {\n              const selectFilters = this._convertToMapboxFilter(\n                selectProperties,\n                true,\n              );\n              selectFilters.forEach((x) => filters_.push(x));\n            } else if (this._selectedFeatureIds) {\n              filters_.push([\n                '!in',\n                this.featureIdName,\n                ...this._selectedFeatureIds,\n              ]);\n            }\n            if (propertyFilters) {\n              propertyFilters.forEach((x) => filters_.push(x));\n            }\n            this.map.setFilter(layerName, filters_);\n          }\n        }\n      }\n    }\n  }\n\n  protected _convertToMapboxFilter(\n    filters: PropertiesFilter,\n    reverse = false,\n  ): (any[] | 'all' | 'any' | undefined)[] {\n    const _operationsAliases = reverse ? reversOperations : operationsAliases;\n    const filter = filters.map((x) => {\n      if (typeof x === 'string') {\n        return x;\n      } else if (isPropertyFilter(x)) {\n        const [field, operation, value] = x;\n        const operationAlias = _operationsAliases[operation];\n        if (operation === 'in' || operation === 'notin') {\n          return [operationAlias, field, ...value];\n        }\n        return [operationAlias, field, value];\n      }\n    });\n    return filter;\n  }\n\n  protected isFeatureSelected(feature: Feature): boolean {\n    if (this._selectedFeatureIds && this._selectedFeatureIds.length) {\n      const filterId = this._getFeatureFilterId(feature);\n      if (filterId) {\n        return this._selectedFeatureIds.indexOf(filterId) !== -1;\n      }\n    } else if (this._selectProperties && this._selectProperties.length) {\n      return featureFilter(feature, this._selectProperties);\n    }\n    return false;\n  }\n\n  protected _removeAllPopup(): void {\n    for (const p of this._openedPopup) {\n      p[1].remove();\n    }\n    this._openedPopup.length = 0;\n  }\n\n  protected async _openPopup({\n    coordinates,\n    feature,\n    options = {},\n    type,\n    refresh,\n  }: {\n    coordinates?: LngLatLike;\n    feature: Feature;\n    options?: PopupOptions;\n    type: OnLayerSelectType;\n    refresh?: boolean;\n  }): Promise<void> {\n    if (refresh && coordinates) {\n      const openedPopup = this._openedPopup.find((x) => x[0].id === feature.id);\n      if (openedPopup) {\n        openedPopup[1].setLngLat(coordinates);\n        return;\n      }\n    }\n    const map = this.map;\n    if (!map) return;\n    let popup: Popup;\n    const _closeHandlers: PopupOnCloseFunction[] = [];\n    const onClose = (handler: PopupOnCloseFunction) => {\n      _closeHandlers.push(handler);\n    };\n    const close = () => {\n      if (popup) {\n        this._removePopup(popup);\n      }\n    };\n    const {\n      maxWidth,\n      popupContent,\n      createPopupContent,\n      closeButton: closeBtn,\n    } = options;\n    const closeButton = closeBtn ?? !this.options.selectOnHover;\n\n    const content = createPopupContent\n      ? await createPopupContent({\n          type,\n          close,\n          onClose,\n          ...this._createLayerOptions(feature),\n        })\n      : popupContent;\n    coordinates =\n      coordinates || (feature && (getCentroid(feature) as [number, number]));\n    if (content && coordinates) {\n      const html =\n        typeof content === 'string' ? makeHtmlFromString(content) : content;\n      const popupOpt: maplibregl.PopupOptions = {\n        closeButton,\n        closeOnClick: false,\n      };\n      if (maxWidth) {\n        popupOpt.maxWidth = typeof maxWidth === 'number' ? maxWidth + 'px' : '';\n      }\n      popup = new Popup(popupOpt);\n      popup.setLngLat(coordinates).setDOMContent(html).addTo(map);\n\n      const unselectOnClose =\n        this.options.popupOptions?.unselectOnClose ?? true;\n      if (unselectOnClose) {\n        popup.once('close', () => {\n          close();\n        });\n      }\n\n      this._openedPopup.push([feature, popup, _closeHandlers]);\n    }\n  }\n\n  protected _openLabel(f: Feature, lngLat?: [number, number]): void {\n    const map = this.map;\n    const { labelField } = this.options;\n    if (map && labelField) {\n      const popupOpt: maplibregl.PopupOptions = {\n        closeButton: false,\n        closeOnClick: false,\n        closeOnMove: this.options.labelOnHover,\n      };\n      const text = f.properties && f.properties[labelField];\n      if (text) {\n        const isOpened = this._openedPopup.find((x) => x[0].id === f.id);\n        if (!isOpened) {\n          const popup = new Popup(popupOpt);\n          lngLat = lngLat ?? (getCentroid(f) as [number, number]);\n          popup.setLngLat(lngLat).setText(text).addTo(map);\n          this._openedPopup.push([f, popup, []]);\n        }\n      }\n    }\n  }\n\n  protected _closeLabel(): void {\n    this._removeAllPopup();\n  }\n\n  protected _removeFeaturePopup(feature: Feature, doNotUnselect = false): void {\n    const openedPopup = this._openedPopup.find((x) => x[0].id === feature.id);\n    if (openedPopup) {\n      this._removePopup(openedPopup[1], doNotUnselect);\n    }\n  }\n\n  protected _createLayerOptions(feature: Feature): LayerDefinition {\n    return {\n      target: this,\n      feature,\n      ...createFeaturePositionOptions(feature),\n    };\n  }\n\n  private _removePopup(popup: Popup, doNotUnselect = false) {\n    const map = this.map;\n    if (map) {\n      popup.remove();\n      const index = this._openedPopup.findIndex((x) => x[1] === popup);\n      if (index !== -1) {\n        const unselectOnClose =\n          this.options.popupOptions?.unselectOnClose ?? true;\n        const [feature, , closeHandlers] = this._openedPopup[index];\n        for (const h of closeHandlers) {\n          h(this._createLayerOptions(feature));\n        }\n        closeHandlers.length = 0;\n        if (unselectOnClose && !doNotUnselect) {\n          this._unselectFeature(feature);\n        }\n        this._openedPopup.splice(index, 1);\n      }\n    }\n  }\n\n  private _getFeatureFromPoint(\n    evt: MapEventType['click'] & MapMouseEvent,\n  ): Feature | undefined {\n    // not work correct\n    // const features = this.map.queryRenderedFeatures(e.point, {\n    //   layers: this.layer\n    // });\n\n    const map = this.map;\n    if (map) {\n      if (this.options.onMouseOver && this.layer) {\n        let feature: Feature | undefined;\n        this.layer.find((a) => {\n          const features_ = map.queryRenderedFeatures(evt.point, {\n            layers: [a],\n          });\n          if (features_.length) {\n            feature = features_[0] as Feature;\n            return true;\n          }\n          return false;\n        });\n        return feature;\n      }\n    }\n  }\n\n  private _onLayerMouseMove(evt: MapEventType['mousemove'] & MapMouseEvent) {\n    const map = this.map;\n    if (map) {\n      const { onMouseOver, selectOnHover, selectable, labelOnHover } =\n        this.options;\n      const event = convertMapClickEvent(evt);\n      if (onMouseOver || selectOnHover || labelOnHover) {\n        const feature = this._getFeatureFromPoint(evt);\n        if (onMouseOver && this.layer) {\n          onMouseOver({\n            event,\n            layer: this,\n            source: evt,\n            feature,\n            ...createFeaturePositionOptions(feature || []),\n          });\n        }\n        if (feature) {\n          if (selectOnHover) {\n            this._featureSelect(feature);\n          }\n          if (labelOnHover) {\n            for (const o of this._openedPopup) {\n              this._removePopup(o[1], true);\n              // if (o[0].id !== feature.id) {\n              // }\n            }\n            this._openLabel(feature, event.lngLat as [number, number]);\n          }\n        }\n      }\n      if (selectable) {\n        map.getCanvas().style.cursor = 'pointer';\n      }\n    }\n  }\n\n  private _onLayerMouseLeave(evt: MapEventType['mousemove'] & MapMouseEvent) {\n    const { onMouseOut, labelOnHover, selectOnHover } = this.options;\n    if (this.map) {\n      if (onMouseOut) {\n        onMouseOut({\n          event: convertMapClickEvent(evt),\n          layer: this,\n          source: evt,\n        });\n      }\n      this.map.getCanvas().style.cursor = '';\n    }\n    if (selectOnHover) {\n      this.unselect();\n    }\n    if (labelOnHover) {\n      this._closeLabel();\n    }\n  }\n\n  private _detectPaintType(paint: Paint): string | undefined {\n    if ('type' in paint) {\n      return paint.type;\n    } else if (typeof paint === 'function') {\n      try {\n        const falsePaint = paint({\n          type: 'Feature',\n          properties: {},\n          geometry: {} as Geometry,\n        });\n        return this._detectPaintType(falsePaint);\n      } catch (er) {\n        //\n      }\n    }\n  }\n\n  private _addEventsListeners() {\n    if (this.layer && this.options) {\n      this.layer.forEach((x) => {\n        if (this.$onLayerMouseMove && this.map) {\n          this.map.on('mousemove', x, this.$onLayerMouseMove);\n        }\n        if (this.$onLayerMouseLeave && this.map) {\n          this.map.on('mouseleave', x, this.$onLayerMouseLeave);\n        }\n      });\n    }\n  }\n\n  private _removeEventListeners() {\n    if (this.$onLayerMouseMove && this.map) {\n      this.map.off('mousemove', this.$onLayerMouseMove);\n    }\n    if (this.$onLayerMouseLeave && this.map) {\n      this.map.off('mouseleave', this.$onLayerMouseLeave);\n    }\n  }\n}\n","export function makeHtmlFromString(str: string): HTMLElement {\n  const html = document.createElement('div');\n  html.innerHTML = str;\n  return html;\n}\n","import { defined } from '@nextgis/utils';\nimport { featureFilter } from '@nextgis/properties-filter';\n\nimport {\n  Map,\n  GeoJSONSource,\n  FilterSpecification,\n  GeoJSONSourceSpecification,\n  FilterSpecificationInputType,\n} from 'maplibre-gl';\n\nimport { EventOptions, VectorAdapter } from './VectorAdapter';\nimport {\n  createFeaturePositionOptions,\n  getFeatureBounds,\n} from '../utils/getFeaturePosition';\nimport {\n  typeAliasForFilter,\n  geometryFilter,\n  detectType,\n  typeAlias,\n} from '../utils/geomType';\n\nimport type {\n  GeometryCollection,\n  GeoJsonProperties,\n  FeatureCollection,\n  GeometryObject,\n  GeoJsonObject,\n  Geometry,\n} from 'geojson';\nimport type { VectorAdapterLayerPaint, GetPaintCallback } from '@nextgis/paint';\nimport type { PropertiesFilter } from '@nextgis/properties-filter';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\nimport type {\n  DataLayerFilter,\n  LayerDefinition,\n  GeoJsonAdapterOptions,\n  VectorAdapterLayerType,\n} from '@nextgis/webmap';\nimport type { Feature } from './VectorAdapter';\nimport type { TLayer } from '../MapboxglMapAdapter';\n\nlet ID = 0;\n\ntype Layers = LayerDefinition<Feature<Geometry, GeoJsonProperties>, TLayer>[];\n\nexport class GeoJsonAdapter extends VectorAdapter<GeoJsonAdapterOptions> {\n  selected = false;\n  source?: string;\n  private _features: Feature[] = [];\n  private _filteredFeatureIds?: (string | number)[] | undefined;\n  private _filterFun?: DataLayerFilter<Feature>;\n  private _sources: Record<string, GeoJSONSource> = {};\n\n  constructor(public map: Map, public options: GeoJsonAdapterOptions) {\n    super(map, options);\n    this.source = this._sourceId;\n  }\n\n  async addLayer(options: GeoJsonAdapterOptions): Promise<TLayer> {\n    const layer = await super.addLayer(options);\n\n    // While this is difficult to achieve. Need to download fonts in PBF or learn how to convert text into icon-image\n    // if (options.labelField) {\n    //   this._labelSource = 'label-source-' + this._layerId;\n    //   const labellayer = await this._addLabelLayer();\n    //   labellayer && layer.push(labellayer);\n    // }\n\n    return layer;\n  }\n\n  beforeRemove(): void {\n    if (this.map) {\n      const source = this.map.getSource(this._sourceId);\n      if (source) {\n        this.map.removeSource(this._sourceId);\n      }\n    }\n    super.beforeRemove();\n  }\n\n  clearLayer(cb?: (feature: Feature) => boolean): void {\n    let features: Feature[] = [];\n    const source = this.map.getSource(this._sourceId) as GeoJSONSource;\n    if (cb) {\n      features = this._features = this._features.filter((x) => !cb(x));\n    }\n    this._features = features;\n    source.setData({ type: 'FeatureCollection', features });\n  }\n\n  async addData(data: GeoJsonObject): Promise<void> {\n    let type: VectorAdapterLayerType | undefined;\n    if (this.options.type) {\n      type = this.options.type;\n    }\n    if (!type && data) {\n      const detectedType = detectType(data);\n      type = typeAlias[detectedType];\n    }\n    if (data && type) {\n      const features = this.filterGeometries(data, type);\n      for (const x of features) {\n        // to avoid id = 0 is false\n        const fid = '_' + ID++;\n        x._featureFilterId = fid;\n        if (x.properties) {\n          x.properties[this.featureIdName] = fid;\n        }\n        if (this.options.popup) {\n          this._openPopup({\n            feature: x,\n            type: 'api',\n            options: this.options.popupOptions,\n          });\n        }\n      }\n      if (this._filterFun) {\n        this._filter(this._filterFun);\n      }\n      await this._updateLayerPaint(type);\n      const source = this.map.getSource(this._sourceId) as GeoJSONSource;\n      source.setData({\n        type: 'FeatureCollection',\n        features: this._features,\n      });\n      if (this.options.labelField) {\n        this._updateLabels();\n      }\n    }\n  }\n\n  getLayers(): Layers {\n    const filtered = this._filteredFeatureIds;\n    const filterProperties = this._filterProperties;\n    if (filterProperties) {\n      this._updateWithNativeFilter(filterProperties);\n    }\n    return this._getFeatures().map((feature) => {\n      let visible = true;\n      if (filterProperties && feature.properties) {\n        visible = featureFilter(feature, filterProperties);\n      } else if (filtered) {\n        const id = this._getFeatureFilterId(feature);\n        if (id !== undefined) {\n          visible = filtered.indexOf(id) !== -1;\n        }\n      }\n      return {\n        visible,\n        ...this._createLayerOptions(feature),\n      };\n    });\n  }\n\n  filter(fun: DataLayerFilter<Feature, TLayer>): void {\n    this._filterFun = fun;\n    this._filter(fun);\n  }\n\n  removeFilter(): void {\n    this._filterFun = undefined;\n    this._filteredFeatureIds = undefined;\n    this._updateFilter();\n  }\n\n  getSelected(): Layers {\n    const selected: LayerDefinition<Feature, TLayer>[] = [];\n    const selectedFeatureIds = this._selectedFeatureIds;\n    const selectProperties = this._selectProperties;\n    const allFeatures = this._getFeatures();\n    if (selectedFeatureIds && selectedFeatureIds.length) {\n      allFeatures.forEach((x) => {\n        const id = this._getFeatureFilterId(x);\n        if (id && selectedFeatureIds.indexOf(id) !== -1) {\n          selected.push(this._createLayerOptions(x));\n        }\n      });\n    } else if (this.source && selectProperties) {\n      allFeatures\n        .filter((x) => featureFilter(x, selectProperties))\n        .forEach((x) => {\n          selected.push(this._createLayerOptions(x));\n        });\n    }\n    return selected;\n  }\n\n  select(find?: DataLayerFilter<Feature, TLayer> | PropertiesFilter): void {\n    if (find) {\n      if (typeof find === 'function') {\n        const features = this._getFeatures().filter((x) =>\n          find(this._createLayerOptions(x)),\n        );\n        this._selectFeature(features);\n      } else {\n        this.selected = true;\n        this._selectProperties = find;\n        super._updateFilter();\n        this._fireOnLayerSelectEvent();\n      }\n    } else if (!this.selected) {\n      this._selectFeature(this._getFeatures());\n    }\n  }\n\n  unselect(find?: DataLayerFilter<Feature, TLayer> | PropertiesFilter): void {\n    this._selectProperties = undefined;\n    if (find) {\n      if (typeof find === 'function') {\n        const features = this._getFeatures().filter((x) =>\n          find(this._createLayerOptions(x)),\n        );\n        this._unselectFeature(features);\n        this.selected = Array.isArray(this._selectedFeatureIds) ? true : false;\n      }\n    } else if (this.selected) {\n      this.selected = false;\n      this._unselectFeature();\n    }\n    this._removeAllPopup();\n  }\n\n  /** @deprecated use {@link GeoJsonAdapter.getBounds} instead */\n  getExtent(): LngLatBoundsArray | undefined {\n    return this.getBounds();\n  }\n\n  getBounds(): LngLatBoundsArray {\n    return getFeatureBounds(this._features);\n  }\n\n  protected async _beforeLayerLayer(sourceId: string): Promise<void> {\n    let source = this.map.getSource(sourceId) as GeoJSONSource;\n    if (!source) {\n      const sourceOpt: GeoJSONSourceSpecification = {\n        type: 'geojson',\n        data: {\n          type: 'FeatureCollection',\n          features: [],\n        },\n      };\n      const _opts: (keyof GeoJSONSourceSpecification)[] = [\n        'cluster',\n        'clusterMaxZoom',\n        'clusterRadius',\n      ];\n      for (const x of _opts) {\n        const value = (this.options as Record<string, unknown>)[x];\n        if (value !== undefined) {\n          Object.defineProperty(sourceOpt, x, { value });\n        }\n      }\n      this.map.addSource(sourceId, sourceOpt);\n      source = this.map.getSource(sourceId) as GeoJSONSource;\n    }\n    this._sources[sourceId] = source;\n  }\n\n  protected async _onLayerAdd(): Promise<void> {\n    if (this.options.data) {\n      await this.addData(this.options.data);\n    } else if (this.options.type) {\n      await this._updateLayerPaint(this.options.type);\n    }\n  }\n\n  protected async _createPaintForType(\n    paint: VectorAdapterLayerPaint | GetPaintCallback,\n    type: VectorAdapterLayerType,\n    name: string,\n  ): Promise<any> {\n    if (typeof paint === 'function') {\n      return await this._getPaintFromCallback(paint, type, name);\n    } else {\n      return super._createPaintForType(paint, type, name);\n    }\n  }\n\n  protected _selectFeature(\n    feature: Feature | Feature[],\n    opt?: { silent: boolean },\n  ): Feature[] {\n    let selectedFeatureIds = this._selectedFeatureIds || [];\n    if (this.options && !this.options.multiselect) {\n      selectedFeatureIds = [];\n    }\n    let features: Feature[] = [];\n    if (Array.isArray(feature)) {\n      features = feature;\n    } else {\n      features = [feature];\n    }\n    features.forEach((f) => {\n      const id = this._getFeatureFilterId(f);\n      if (id !== undefined) {\n        selectedFeatureIds.push(id);\n      }\n    });\n    this._selectProperties = undefined;\n    this._selectedFeatureIds = selectedFeatureIds;\n    this._updateFilter(opt);\n    return features;\n  }\n\n  protected _unselectFeature(\n    feature?: Feature | Feature[],\n    opt?: EventOptions,\n  ): void {\n    if (feature) {\n      let features: Feature[] = [];\n      if (Array.isArray(feature)) {\n        features = feature;\n      } else {\n        features = [feature];\n      }\n      if (features.length) {\n        for (const f of features) {\n          const id = this._getFeatureFilterId(f);\n          const selected = this._selectedFeatureIds;\n          if (selected && id !== undefined) {\n            const index = selected.indexOf(id);\n            if (index !== -1) {\n              selected.splice(index, 1);\n            }\n          }\n          this._removeFeaturePopup(f, true);\n        }\n      }\n    } else {\n      this._selectedFeatureIds = false;\n    }\n    this._updateFilter(opt);\n  }\n\n  protected _updateFilter(opt: EventOptions = {}): void {\n    const map = this.map;\n    if (!map) return;\n\n    // it is not yet possible to use callbacks and properties filters together\n    if (this._filterProperties || this._selectProperties) {\n      super._updateFilter(opt);\n      const silent = opt.silent ?? false;\n      if (!silent) {\n        this._fireOnLayerSelectEvent();\n      }\n      return;\n    }\n    const selected = this._selectedFeatureIds;\n    let selectionArray: FilterSpecificationInputType[] = [];\n    const filteredArray: FilterSpecificationInputType[] = [];\n    const filtered = this._filteredFeatureIds;\n    if (filtered) {\n      const features = this._getFeatures();\n      for (const x of features) {\n        const id = this._getFeatureFilterId(x);\n        if (id !== undefined && filtered.indexOf(id) !== -1) {\n          if (selected && selected.indexOf(id) !== -1) {\n            selectionArray.push(id);\n          } else {\n            filteredArray.push(id);\n          }\n        }\n      }\n    } else if (selected) {\n      selectionArray = selected;\n    }\n    this.selected = !!selected;\n    const layers = this.layer;\n    if (layers) {\n      for (const t of this._types) {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          const geomFilter = ['==', '$type', geomType];\n          const layerName = this._getLayerNameFromType(t);\n          const selLayerName = this._getSelectionLayerNameFromType(t);\n          if (layers.indexOf(selLayerName) !== -1) {\n            if (this._selectionName) {\n              const selectFilter: FilterSpecification = [\n                'in',\n                this.featureIdName as FilterSpecificationInputType,\n              ];\n              selectFilter.push(...selectionArray);\n\n              map.setFilter(selLayerName, ['all', geomFilter, selectFilter]);\n            }\n          }\n          if (layers.indexOf(layerName) !== -1) {\n            const filter_: any[] = ['all', geomFilter];\n            if (filtered) {\n              filter_.push(['in', this.featureIdName, ...filteredArray]);\n            } else {\n              filter_.push(['!in', this.featureIdName, ...selectionArray]);\n              this._updateWithNativeFilter(filter_);\n            }\n            map.setFilter(layerName, filter_);\n          }\n        }\n      }\n    }\n  }\n\n  // TODO: need to download fonts in PBF or learn how to convert text into icon-image\n  // private _addLabelLayer() {\n  //   if (!this._labelSource) return;\n\n  //   const type = 'symbol';\n  //   const id = this._getLayerNameFromType(type);\n  //   this.map.addSource(this._labelSource, {\n  //     type: 'geojson',\n  //     data: {\n  //       type: 'FeatureCollection',\n  //       features: [],\n  //     },\n  //   });\n\n  //   const symbolLayer: SymbolLayer = {\n  //     id,\n  //     type,\n  //     source: this._labelSource,\n  //     layout: {\n  //       'icon-image': 'custom-marker',\n  //       // 'text-field': ['get', this.options.labelField],\n  //       // 'text-variable-anchor': ['top', 'bottom', 'left', 'right'],\n  //       // 'text-anchor': 'top',\n  //       // 'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],\n  //       // 'text-justify': 'auto',\n  //       // 'icon-image': ['get', 'icon'],\n  //     },\n  //   };\n  //   this._addLayer(symbolLayer);\n  //   return id;\n  // }\n\n  private _getFeatures(): Feature[] {\n    if (this.source) {\n      // const features = this.map.querySourceFeatures(this.source);\n      // return features;\n\n      const source = this.map.getSource(this.source) as GeoJSONSource;\n      if (source) {\n        const geojson =\n          typeof source._data === 'string'\n            ? (JSON.parse(source._data) as GeoJSON.GeoJSON)\n            : source._data;\n        if (geojson) {\n          if (geojson.type === 'Feature') {\n            return [geojson];\n          } else if (geojson.type === 'FeatureCollection') {\n            return geojson.features;\n          }\n        }\n        return [];\n      }\n    }\n    return this._features;\n  }\n\n  private _filter(fun: DataLayerFilter<Feature, TLayer>) {\n    const filtered: (string | number)[] = [];\n    this._getFeatures().forEach((feature) => {\n      const ok = fun(this._createLayerOptions(feature));\n      const id = this._getFeatureFilterId(feature);\n      if (ok && id) {\n        filtered.push(id);\n      }\n    });\n    this._filteredFeatureIds = filtered;\n    this._updateFilter();\n    this._updateLabels();\n  }\n\n  private filterGeometries(\n    data: GeoJsonObject,\n    type: VectorAdapterLayerType,\n  ): Feature[] {\n    let newFeatures: Feature[] = [];\n    if (data.type === 'FeatureCollection') {\n      const features = (data as FeatureCollection).features.filter((f) =>\n        geometryFilter(f.geometry.type, type),\n      ) as Feature[];\n      (data as FeatureCollection).features = features;\n      newFeatures = features;\n    } else if (data.type === 'Feature') {\n      const allow = geometryFilter((data as Feature).geometry.type, type);\n      if (!allow) {\n        return [];\n      }\n      newFeatures.push(data as Feature);\n    } else if (data.type === 'GeometryCollection') {\n      const geomCollection = data as GeometryCollection;\n      geomCollection.geometries = geomCollection.geometries.filter((g) =>\n        geometryFilter(g.type, type),\n      );\n      newFeatures = geomCollection.geometries.map((x) => {\n        const f: Feature = {\n          type: 'Feature',\n          geometry: x as GeometryObject,\n          properties: {},\n        };\n        return f;\n      });\n    } else if (typeAlias[data.type]) {\n      const obj: Feature = {\n        type: 'Feature',\n        geometry: data as GeometryObject,\n        properties: {},\n      };\n      newFeatures = [obj];\n    }\n    this._features = this._features.concat(newFeatures);\n    return newFeatures;\n  }\n\n  private async _getPaintFromCallback(\n    paint: GetPaintCallback,\n    type: VectorAdapterLayerType,\n    name: string,\n  ) {\n    const style: any = {};\n    style.type = paint.type;\n    for (const feature of this._features) {\n      const _paint = paint(feature);\n      if (_paint.type === 'icon') {\n        await this._registerImage(_paint);\n        if (feature.properties) {\n          feature.properties['_icon-image-' + name] = _paint.html;\n        }\n        style['icon-image'] = `{_icon-image-${name}}`;\n      } else {\n        let p: keyof typeof _paint;\n        for (p in _paint) {\n          const toSave = _paint[p];\n          if (feature.properties) {\n            feature.properties[`_paint_${p}_${name}`] = toSave;\n          }\n          style[p] = ['get', `_paint_${p}_${name}`];\n        }\n      }\n    }\n    if ('icon-image' in style) {\n      return style;\n    }\n    const styleFromCb = this._createPaintForType(style, type, name);\n    return styleFromCb;\n  }\n\n  private _fireOnLayerSelectEvent() {\n    if (this.options.onSelect) {\n      const features_: Feature[] = [];\n      this.getSelected().forEach((x) => {\n        if (x.feature) {\n          features_.push(x.feature);\n        }\n      });\n      const features = features_.length ? features_ : undefined;\n      this.options.onSelect({\n        layer: this,\n        features,\n        type: 'api',\n        ...createFeaturePositionOptions(features || []),\n      });\n    }\n  }\n\n  // Workaround for displaying labels.\n  // It is necessary to achieve that the labels are shown through vector layer symbols\n  private _updateLabels() {\n    this._removeAllPopup();\n    const filtered = this._filteredFeatureIds || [];\n    const features = this._features;\n    const { labelField, labelOnHover } = this.options;\n    if (labelField && !labelOnHover) {\n      for (const f of features) {\n        const inFilter = filtered.length\n          ? defined(f._featureFilterId) &&\n            filtered.indexOf(f._featureFilterId) !== -1\n          : true;\n        if (inFilter) {\n          this._openLabel(f);\n        }\n      }\n    }\n  }\n}\n","import { Map } from 'maplibre-gl';\n\ninterface SetupLayerTransformRequestOptions {\n  map: Map;\n  url: string;\n  headers: Record<string, string>;\n}\n\nexport function setupLayerTransformRequest({\n  map,\n  url,\n  headers,\n}: SetupLayerTransformRequestOptions) {\n  const transformRequests = map.transformRequests;\n  transformRequests.push((url_: string) => {\n    let staticUrl = url_;\n    staticUrl = staticUrl.replace(/(z=\\d+)/, 'z={z}');\n    staticUrl = staticUrl.replace(/(x=\\d+)/, 'x={x}');\n    staticUrl = staticUrl.replace(/(y=\\d+)/, 'y={y}');\n    if (staticUrl === url) {\n      return {\n        url: url_,\n        headers,\n      };\n    }\n  });\n}\n","import type { Map } from 'maplibre-gl';\nimport type { MainLayerAdapter, RasterAdapterOptions } from '@nextgis/webmap';\nimport type { TLayer } from '../MapboxglMapAdapter';\n\nlet ID = 0;\n\nexport abstract class BaseRasterAdapter<\n  O extends RasterAdapterOptions = RasterAdapterOptions,\n> implements MainLayerAdapter<Map, TLayer, O>\n{\n  layer?: TLayer;\n  map?: Map;\n  protected readonly _layerId: string;\n\n  constructor(map: Map, public options: O) {\n    this.map = map;\n    this._layerId = `layer-${ID++}`;\n  }\n\n  beforeRemove(): void {\n    Object.assign(this, { map: undefined });\n  }\n\n  setOpacity(value: number): void {\n    this.options.opacity = Number(value);\n    this.updateOpacity();\n  }\n\n  protected updateOpacity(): void {\n    const opacity = this.options.opacity;\n    if (this.map && this.layer && opacity !== undefined) {\n      for (const l of this.layer) {\n        this.map.setPaintProperty(l, 'raster-opacity', opacity);\n      }\n    }\n  }\n\n  abstract addLayer(options: O): TLayer | Promise<TLayer> | undefined;\n}\n","import { convertZoomLevel } from '../utils/convertZoomLevel';\nimport { setupLayerTransformRequest } from '../utils/setupLayerTransformRequest';\nimport { BaseRasterAdapter } from './BaseRasterAdapter';\n\nimport type {\n  RasterSourceSpecification,\n  RasterLayerSpecification,\n  LayerSpecification,\n} from 'maplibre-gl';\nimport type {\n  MainLayerAdapter,\n  TileAdapterOptions,\n  RasterAdapterOptions,\n} from '@nextgis/webmap';\n\ntype Layer = RasterLayerSpecification;\n\nexport class TileAdapter<O extends RasterAdapterOptions = TileAdapterOptions>\n  extends BaseRasterAdapter<O>\n  implements MainLayerAdapter\n{\n  addLayer(options: O & { before?: string }): string[] | undefined {\n    if (this.map) {\n      options = { ...this.options, ...(options || {}) };\n      this.options = options;\n      const { minZoom, maxZoom } = options;\n      const tiles: string[] = [];\n      const subdomains: string[] | undefined =\n        typeof options.subdomains === 'string'\n          ? options.subdomains.split('')\n          : options.subdomains;\n      if (subdomains?.length) {\n        subdomains.forEach((x) => {\n          tiles.push(options.url.replace(/{s}/, x));\n        });\n      } else {\n        tiles.push(options.url);\n      }\n      if (options.headers) {\n        setupLayerTransformRequest({\n          map: this.map,\n          url: options.url,\n          headers: options.headers,\n        });\n      }\n\n      const sourceOptions: RasterSourceSpecification = {\n        type: 'raster',\n        // point to our third-party tiles. Note that some examples\n        // show a \"url\" property. This only applies to tilesets with\n        // corresponding TileJSON (such as mapbox tiles).\n        tiles,\n        tileSize: 256, // opt && opt.tileSize ||\n      };\n      if (options.attribution) {\n        sourceOptions.attribution = options.attribution;\n      }\n\n      this.map.addSource(this._layerId + '_source', sourceOptions);\n\n      const layerOptions: Layer = {\n        id: this._layerId,\n        type: 'raster',\n        layout: {\n          visibility: 'none',\n        },\n        source: this._layerId + '_source',\n      };\n      if (minZoom) {\n        layerOptions.minzoom = convertZoomLevel(minZoom);\n      }\n      if (maxZoom) {\n        layerOptions.maxzoom = convertZoomLevel(maxZoom);\n      }\n      if (options.nativeOptions) {\n        Object.assign(options, options.nativeOptions);\n      }\n\n      this.map.addLayer(layerOptions as LayerSpecification, options.before);\n      this.layer = [this._layerId];\n      this.updateOpacity();\n      return this.layer;\n    }\n  }\n}\n","import { setupLayerTransformRequest } from '../utils/setupLayerTransformRequest';\nimport { VectorAdapter } from './VectorAdapter';\n\nimport type { MvtAdapterOptions } from '@nextgis/webmap';\nimport type { VectorLayerSpecification } from '../interfaces';\nimport type { TLayer } from '../MapboxglMapAdapter';\n\nexport class MvtAdapter extends VectorAdapter<MvtAdapterOptions> {\n  static sources: string[] = [];\n\n  source?: string;\n\n  async addLayer(options: MvtAdapterOptions): Promise<TLayer> {\n    const layer = await super.addLayer(options);\n    if (this.map && options.headers) {\n      setupLayerTransformRequest({\n        map: this.map,\n        url: options.url,\n        headers: options.headers,\n      });\n    }\n    this._updateLayerPaint(this.options.type || 'polygon');\n\n    return layer;\n  }\n\n  protected _getAdditionalLayerOptions(): Partial<VectorLayerSpecification> {\n    const exist = MvtAdapter.sources.includes(this.options.url);\n    if (!exist && this.map) {\n      this.map.addSource(this.options.url, {\n        type: 'vector',\n        tiles: [this.options.url],\n      });\n      this.source = this.options.url;\n      MvtAdapter.sources.push(this.options.url);\n    }\n    const mvtLayerOptions: Partial<VectorLayerSpecification> = {\n      source: this.options.url,\n      'source-layer': this.options.sourceLayer,\n    };\n    return mvtLayerOptions;\n  }\n}\n","import { MainLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport { TileAdapter } from './TileAdapter';\n\nconst OPTIONS = {\n  url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n  attribution:\n    '&copy; <a href=\"https://osm.org/copyright\" target=\"_blank\">OpenStreetMap</a> contributors',\n  subdomains: 'abc',\n  name: 'OpenStreetMap',\n};\n\nexport class OsmAdapter extends TileAdapter implements MainLayerAdapter {\n  addLayer(options: Omit<TileAdapterOptions, 'url'>): string[] | undefined {\n    return super.addLayer(Object.assign({}, OPTIONS, options));\n  }\n}\n","import type { ControlPosition, IControl } from 'maplibre-gl';\nimport type { MapControl, CreateControlOptions } from '@nextgis/webmap';\n\nexport function createControl(\n  control: MapControl,\n  options: CreateControlOptions = {},\n): IControl {\n  class Control implements IControl {\n    private _container?: HTMLElement;\n\n    getDefaultPosition() {\n      return 'top-left' as ControlPosition;\n    }\n\n    onAdd() {\n      const element = document.createElement('div');\n      const content = control.onAdd();\n      element.classList.add('maplibregl-ctrl');\n      if (options.bar) {\n        // add custom css for boarder style\n        element.classList.add('maplibregl-bar');\n        element.classList.add('maplibregl-ctrl-group');\n      }\n      if (options.addClass) {\n        element.classList.add(options.addClass);\n      }\n      if (content) {\n        element.appendChild(content);\n      }\n      this._container = element;\n      return this._container;\n    }\n\n    onRemove() {\n      if (this._container) {\n        const parent = this._container.parentNode;\n        if (parent) {\n          parent.removeChild(this._container);\n        }\n      }\n      return control.onRemove();\n    }\n\n    remove() {\n      this.onRemove();\n    }\n  }\n\n  return new Control();\n  // return control;\n}\n","import type { LngLatBoundsLike } from 'maplibre-gl';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\n\nexport function arrayToBoundsLike(bounds: LngLatBoundsArray): LngLatBoundsLike {\n  const e = bounds;\n\n  return [\n    [e[0], e[1]],\n    [e[2], e[3]],\n  ];\n}\n","import { EventEmitter } from 'events';\n\nimport { Map } from 'maplibre-gl';\n\nimport { debounce } from '@nextgis/utils';\n\nimport { GeoJsonAdapter } from './layer-adapters/GeoJsonAdapter';\nimport { WmsAdapter } from './layer-adapters/WmsAdapter';\nimport { MvtAdapter } from './layer-adapters/MvtAdapter';\nimport { OsmAdapter } from './layer-adapters/OsmAdapter';\nimport { TileAdapter } from './layer-adapters/TileAdapter';\nimport { ZoomControl } from './controls/ZoomControl';\nimport { createControl } from './controls/createControl';\nimport { CompassControl } from './controls/CompassControl';\nimport { AttributionControl } from './controls/AttributionControl';\nimport { createButtonControl } from './controls/createButtonControl';\nimport { convertMapClickEvent } from './utils/convertMapClickEvent';\nimport { arrayToBoundsLike } from './utils/arrayToBoundsLike';\nimport { convertZoomLevel } from './utils/convertZoomLevel';\n\nimport type { LngLatBoundsArray, LngLatArray } from '@nextgis/utils';\nimport type {\n  CreateControlOptions,\n  ButtonControlOptions,\n  ControlPosition,\n  LayerAdapter,\n  ViewOptions,\n  MapAdapter,\n  FitOptions,\n  MapControl,\n  MapOptions,\n} from '@nextgis/webmap';\nimport type {\n  IControl,\n  MapEventType,\n  MapMouseEvent,\n  ResourceTypeEnum,\n  LngLatBoundsLike,\n  FitBoundsOptions,\n  RequestParameters,\n  MapSourceDataEvent,\n  StyleSpecification,\n  MapOptions as MapboxOptions,\n} from 'maplibre-gl';\nimport type { Feature } from './layer-adapters/VectorAdapter';\n\nexport type TLayer = string[];\nexport type UnselectCb = () => void;\ntype TLayerAdapter = LayerAdapter<Map, TLayer>;\nconst fitBoundsOptions: FitOptions = {\n  // padding: 100\n};\n\nexport interface MapboxglMapAdapterOptions extends MapOptions<Map> {\n  style?: Partial<StyleSpecification> | string;\n}\n\nexport class MapboxglMapAdapter implements MapAdapter<Map, TLayer, IControl> {\n  static layerAdapters = {\n    TILE: TileAdapter,\n    WMS: WmsAdapter,\n    // IMAGE: TileAdapter,\n    MVT: MvtAdapter,\n    OSM: OsmAdapter,\n    GEOJSON: GeoJsonAdapter,\n  };\n\n  static controlAdapters: { [name: string]: any } = {\n    ZOOM: ZoomControl,\n    COMPASS: CompassControl,\n    ATTRIBUTION: AttributionControl,\n  };\n\n  options: MapboxglMapAdapterOptions = {};\n  map!: Map;\n\n  emitter = new EventEmitter();\n\n  layerAdapters = MapboxglMapAdapter.layerAdapters;\n  controlAdapters = MapboxglMapAdapter.controlAdapters;\n  isLoaded = false;\n\n  private _universalEvents: (keyof MapEventType)[] = [\n    'zoomstart',\n    'zoom',\n    'zoomend',\n    'movestart',\n    'move',\n    'moveend',\n  ];\n  private _positionEvents: (keyof MapEventType)[] = [\n    'mousemove',\n    'mouseout',\n    'mouseover',\n  ];\n  private _unselectCb: UnselectCb[] = [];\n  private _sourceDataLoading: { [name: string]: any[] } = {};\n  private __setLayerOrder: (layers: { [x: string]: TLayerAdapter }) => void;\n\n  constructor() {\n    this.__setLayerOrder = debounce((layers) => this._setLayerOrder(layers));\n  }\n\n  create(options: MapboxglMapAdapterOptions): Promise<unknown> {\n    return new Promise((resolve, reject) => {\n      if (!this.map) {\n        this.options = options;\n        if (options.target || options.map) {\n          if (options.map) {\n            this.map = options.map;\n          } else {\n            if (!options.target) {\n              throw new Error('Map target container is not set');\n            }\n            const style: StyleSpecification | string =\n              typeof options.style === 'string'\n                ? options.style\n                : {\n                    ...{\n                      version: 8,\n                      name: 'Empty style',\n                      sources: {},\n                      layers: [],\n                    },\n                    ...options.style,\n                  };\n            const mapOpt: MapboxOptions = {\n              style,\n              container: options.target,\n              attributionControl: false,\n              bounds: options.bounds as LngLatBoundsLike,\n              fitBoundsOptions: {\n                ...options.fitOptions,\n                ...fitBoundsOptions,\n              },\n              ...(options.mapAdapterOptions || {}),\n            };\n\n            if (options.center !== undefined) {\n              const center = options.center;\n              mapOpt.center = [center[0], center[1]];\n            }\n            if (options.zoom !== undefined) {\n              mapOpt.zoom = convertZoomLevel(options.zoom);\n            }\n            if (options.maxZoom) {\n              mapOpt.maxZoom = convertZoomLevel(options.maxZoom);\n            }\n            if (options.minZoom) {\n              mapOpt.minZoom = convertZoomLevel(options.minZoom);\n            }\n            this.map = new Map(mapOpt);\n          }\n          if (\n            this.map &&\n            this.map._requestManager &&\n            this.map._requestManager._transformRequestFn !== null\n          ) {\n            console.warn('The maplibre transformRequest has been overwritten');\n          }\n          this.map.setTransformRequest(\n            (url: string, resourceType?: ResourceTypeEnum) => {\n              const transformed = this._transformRequest(url, resourceType);\n              if (transformed) {\n                return transformed;\n              } else {\n                return {\n                  url,\n                };\n              }\n            },\n          );\n          this.map.setTransformRequest = () => {\n            throw new Error(\n              `You can no longer overwrite 'transformRequest' with 'setTransformRequest' method.\n              This ability is used for correct work of '@nextgis/mapboxgl-map-adapter'.`,\n            );\n          };\n\n          const onMapLoaded = () => {\n            this.map.transformRequests = [];\n            this.map._onMapClickLayers = [];\n            this.map._addUnselectCb = (args) => this._addUnselectCb(args);\n            this.isLoaded = true;\n            this.emitter.emit('create', this);\n            resolve(this);\n          };\n          if (this.map.loaded()) {\n            onMapLoaded();\n          } else {\n            this.map.once('load', () => {\n              onMapLoaded();\n            });\n          }\n          this._addEventsListeners();\n        }\n      }\n    });\n  }\n\n  destroy(): void {\n    if (this.map) {\n      this.map.remove();\n    }\n  }\n\n  getContainer(): HTMLElement | undefined {\n    return this.map && this.map.getContainer();\n  }\n\n  setView(lngLat: LngLatArray, zoom?: number): void;\n  setView(options: ViewOptions): void;\n  setView(lngLatOrOpt: LngLatArray | ViewOptions, zoom?: number): void {\n    const map = this.map;\n    if (!map) return;\n    if (Array.isArray(lngLatOrOpt)) {\n      const c = lngLatOrOpt;\n      const options: maplibregl.CameraOptions = {\n        center: [c[0], c[1]],\n      };\n      if (zoom) {\n        options.zoom = convertZoomLevel(zoom);\n      }\n      this.map.jumpTo(options);\n    } else {\n      const { zoom, center, maxBounds, bounds, minZoom, maxZoom } = lngLatOrOpt;\n      if (maxBounds !== undefined) {\n        // TODO: remove `as` after maplibre type fix\n        map.setMaxBounds(\n          arrayToBoundsLike(maxBounds as [number, number, number, number]),\n        );\n      }\n      if (center && zoom !== undefined) {\n        this.setView(center, zoom);\n      } else {\n        if (zoom !== undefined) {\n          this.setZoom(zoom);\n        }\n        if (center) {\n          this.setCenter(center);\n        }\n      }\n      if (maxZoom !== undefined) {\n        map.setMaxZoom(convertZoomLevel(maxZoom));\n      }\n      if (minZoom !== undefined) {\n        map.setMinZoom(convertZoomLevel(minZoom));\n      }\n      if (bounds) {\n        this.fitBounds(bounds);\n      }\n    }\n  }\n\n  setCenter(latLng: LngLatArray): void {\n    if (this.map) {\n      this.map.setCenter([latLng[0], latLng[1]]);\n    }\n  }\n\n  getCenter(): LngLatArray | undefined {\n    if (this.map) {\n      const center = this.map.getCenter();\n      return [center.lng, center.lat];\n    }\n  }\n\n  setZoom(zoom: number): void {\n    if (this.map) {\n      this.map.setZoom(convertZoomLevel(zoom));\n    }\n  }\n\n  getZoom(): number | undefined {\n    if (this.map) {\n      const zoom = this.map.getZoom();\n      if (zoom < 1) {\n        return undefined;\n      }\n      return zoom ? zoom + 1 : undefined;\n    }\n  }\n\n  getBounds(): LngLatBoundsArray | undefined {\n    if (this.map) {\n      const bounds = this.map.getBounds();\n      const ar = bounds.toArray();\n      return [ar[0][0], ar[0][1], ar[1][0], ar[1][1]];\n    }\n  }\n\n  // [extent_left, extent_bottom, extent_right, extent_top];\n  fitBounds(e: LngLatBoundsArray, options: FitOptions = {}): void {\n    if (this.map) {\n      const opt: FitBoundsOptions = {\n        linear: true,\n        duration: 0,\n        ...options,\n        ...fitBoundsOptions,\n      };\n      if (options.maxZoom) {\n        opt.maxZoom = convertZoomLevel(options.maxZoom);\n      }\n      this.map.fitBounds(arrayToBoundsLike(e), opt);\n    }\n  }\n\n  setRotation(angle: number): void {\n    // ignore\n  }\n\n  showLayer(layerIds: string[]): void {\n    layerIds &&\n      layerIds.forEach((layerId) => {\n        this._toggleLayer(layerId, true);\n      });\n  }\n\n  hideLayer(layerIds: string[]): void {\n    layerIds &&\n      layerIds.forEach((layerId) => {\n        this._toggleLayer(layerId, false);\n      });\n  }\n\n  removeLayer(layerIds: string[]): void {\n    const _map = this.map;\n    if (_map && layerIds && Array.isArray(layerIds)) {\n      layerIds.forEach((layerId) => {\n        _map.removeLayer(layerId);\n        const source = _map.getSource(layerId);\n        if (source) {\n          _map.removeSource(layerId);\n        }\n      });\n    }\n  }\n\n  setLayerOrder(\n    layerIds: string[],\n    order: number,\n    layers: { [x: string]: TLayerAdapter },\n  ): void {\n    this.__setLayerOrder(layers);\n  }\n\n  setLayerOpacity(layerIds: string[], opacity: number): void {\n    const _map = this.map;\n    if (_map) {\n      layerIds.forEach((layerId) => {\n        this._onMapLoad().then(() => {\n          const layer = _map.getLayer(layerId);\n          if (layer) {\n            if (layer.type === 'symbol') {\n              _map.setPaintProperty(layerId, 'text-opacity', opacity);\n              _map.setPaintProperty(layerId, 'icon-opacity', opacity);\n            } else {\n              _map.setPaintProperty(layerId, layer.type + '-opacity', opacity);\n            }\n          }\n        });\n      });\n    }\n  }\n\n  createControl(control: MapControl, options?: CreateControlOptions): IControl {\n    return createControl(control, options);\n  }\n\n  createButtonControl(options: ButtonControlOptions): IControl {\n    return createButtonControl(options);\n  }\n\n  addControl(\n    control: IControl,\n    position: ControlPosition,\n  ): IControl | undefined {\n    if (this.map) {\n      this.map.addControl(control, position);\n      return control;\n    }\n  }\n\n  removeControl(control: IControl): void {\n    if (this.map) {\n      this.map.removeControl(control);\n    }\n  }\n\n  onMapClick(evt: MapEventType['click'] & MapMouseEvent): void {\n    const map = this.map;\n    const emitData = convertMapClickEvent(evt);\n    this.emitter.emit('preclick', emitData);\n    if (map) {\n      const topFirst = map._onMapClickLayers.sort((a, b) => {\n        if (a.options && a.options.order && b.options && b.options.order) {\n          return b.options.order - a.options.order;\n        }\n        return 1;\n      });\n      let firstSelectedLayer: Feature | undefined = undefined;\n      for (const l of topFirst) {\n        let firstSelectedLayer_: Feature | undefined = undefined;\n        if (!firstSelectedLayer) {\n          firstSelectedLayer_ = l._onLayerClick(evt);\n        }\n        if (!firstSelectedLayer_) {\n          const unselectOnClick = l.options.unselectOnClick ?? true;\n          if (unselectOnClick) {\n            l.unselect();\n          }\n        } else if (l.options.unselectOnSecondClick) {\n          // l.unselect();\n        }\n        if (!firstSelectedLayer && firstSelectedLayer_) {\n          firstSelectedLayer = firstSelectedLayer_;\n        }\n      }\n\n      this.emitter.emit('click', emitData);\n    }\n  }\n\n  private _onMapLoad(cb?: () => any): Promise<Map> {\n    return new Promise<Map>((resolve) => {\n      const _resolve = () => {\n        if (cb) {\n          cb();\n        }\n        if (this.map) {\n          resolve(this.map);\n        }\n      };\n      if (this.isLoaded) {\n        // map.loaded()\n        _resolve();\n      } else if (this.map) {\n        this.emitter.once('create', () => {\n          _resolve();\n        });\n      }\n    });\n  }\n\n  private _setLayerOrder(layers: { [x: string]: TLayerAdapter }): void {\n    const _map = this.map;\n    if (_map) {\n      const baseLayers: TLayerAdapter[] = [];\n      let orderedLayers: TLayerAdapter[] = [];\n      for (const l in layers) {\n        const layer = layers[l];\n        if (layer.options.baselayer) {\n          baseLayers.push(layer);\n        } else {\n          orderedLayers.push(layer);\n        }\n      }\n\n      // normalize layer ordering\n      baseLayers.forEach((x) => {\n        if (x.layer) {\n          x.layer.forEach((y) => {\n            _map.moveLayer(y);\n          });\n        }\n      });\n\n      orderedLayers = orderedLayers.sort((a, b) => {\n        return a.options.order !== undefined && b.options.order !== undefined\n          ? a.options.order - b.options.order\n          : 0;\n      });\n\n      for (let fry = 0; fry < orderedLayers.length; fry++) {\n        const mem = orderedLayers[fry];\n        const _layers = this._getLayerIds(mem);\n        _layers.forEach((x) => {\n          _map.moveLayer(x);\n        });\n      }\n    }\n  }\n\n  private _getLayerIds(mem: TLayerAdapter): string[] {\n    let _layers: TLayer = [];\n    if (mem) {\n      if (Array.isArray(mem.layer)) {\n        _layers = mem.layer;\n      } else if (mem.getDependLayers) {\n        const dependLayers = mem.getDependLayers();\n        dependLayers.forEach((x) => {\n          // @ts-ignore Update x interface\n          const layer: TLayer = (x.layer && x.layer.layer) || x;\n          if (Array.isArray(layer)) {\n            layer.forEach((y) => {\n              _layers.push(y);\n            });\n          }\n        });\n      }\n    }\n    return _layers;\n  }\n\n  private _toggleLayer(layerId: string, status: boolean): void {\n    this._onMapLoad().then((_map) => {\n      _map.setLayoutProperty(\n        layerId,\n        'visibility',\n        status ? 'visible' : 'none',\n      );\n    });\n  }\n\n  private _onMapSourceData(data: MapSourceDataEvent) {\n    if (data.dataType === 'source') {\n      const isLoaded = data.isSourceLoaded;\n      const emit = (target: string) => {\n        this.emitter.emit('data-loaded', { target });\n      };\n      this._onDataLoad(data, isLoaded, emit);\n    }\n  }\n\n  private _onMapError(data: ErrorEvent & MapSourceDataEvent) {\n    if (this._sourceDataLoading[data.sourceId]) {\n      const isLoaded = data.isSourceLoaded;\n      const emit = (target: string) => {\n        this.emitter.emit('data-error', { target });\n      };\n      this._onDataLoad(data, isLoaded, emit);\n    }\n  }\n\n  private _onDataLoad(\n    data: { sourceId: string; tile: any },\n    isLoaded = false,\n    emit: (sourceId: string) => void,\n  ) {\n    // if all sources is loaded emmit event for all and clean mem\n    if (isLoaded) {\n      Object.keys(this._sourceDataLoading).forEach((x) => {\n        emit(x);\n      });\n      this._sourceDataLoading = {};\n    } else {\n      // check if all tiles in layer is loaded\n      const tiles = this._sourceDataLoading[data.sourceId];\n      if (tiles && data.tile) {\n        const index = tiles.indexOf(data.tile);\n        if (index !== -1) {\n          this._sourceDataLoading[data.sourceId].splice(index, 1);\n        }\n        // if no more loaded tiles in layer emit event and clean mem only for this layer\n        if (!tiles.length) {\n          emit(data.sourceId);\n          delete this._sourceDataLoading[data.sourceId];\n        }\n      }\n    }\n  }\n\n  private _addUnselectCb(cb: UnselectCb) {\n    for (const p of this._unselectCb) {\n      p();\n    }\n    this._unselectCb.length = 0;\n    this._unselectCb.push(cb);\n  }\n\n  private _transformRequest(\n    url: string,\n    resourceType?: ResourceTypeEnum,\n  ): RequestParameters | undefined {\n    const transformRequests = this.map && this.map.transformRequests;\n    if (transformRequests) {\n      for (const r of transformRequests) {\n        const params = r(url, resourceType) as RequestParameters;\n        if (params) {\n          return params;\n        }\n      }\n      return undefined;\n    }\n  }\n\n  private _addEventsListeners(): void {\n    const _map = this.map;\n    if (_map) {\n      // write mem for start loaded layers\n      _map.on('sourcedataloading', (data) => {\n        this._sourceDataLoading[data.sourceId] =\n          this._sourceDataLoading[data.sourceId] || [];\n        if (data.tile) {\n          this._sourceDataLoading[data.sourceId].push(data.tile);\n        }\n      });\n      // emmit data-loaded for each layer or all sources is loaded\n      _map.on('sourcedata', this._onMapSourceData.bind(this));\n      _map.on('error', this._onMapError.bind(this));\n      _map.on('click', (evt) => {\n        this.onMapClick(evt);\n      });\n\n      for (const e of this._universalEvents) {\n        _map.on(e, () => this.emitter.emit(e, this));\n      }\n      for (const e of this._positionEvents) {\n        _map.on(e, (evt) =>\n          this.emitter.emit(e, convertMapClickEvent(evt as MapMouseEvent)),\n        );\n      }\n    }\n  }\n}\n","import { IControl } from 'maplibre-gl';\nimport { ButtonControlOptions } from '@nextgis/webmap';\nimport { createControl } from './createControl';\n\nexport function createButtonControl(options: ButtonControlOptions): IControl {\n  const link = document.createElement('button');\n  link.className = 'maplibregl-ctrl-icon';\n\n  link.setAttribute('role', 'button');\n  if (options.title) {\n    link.title = options.title;\n    link.setAttribute('aria-label', options.title);\n  }\n\n  if (options.html) {\n    if (options.html instanceof HTMLElement) {\n      link.appendChild(options.html);\n    } else {\n      link.innerHTML = options.html;\n    }\n    const child = link.firstElementChild as HTMLElement;\n    if (child) {\n      child.style.width = '100%';\n      child.style.height = '100%';\n      child.style.lineHeight = (link.offsetHeight || 30) + 'px';\n    }\n  }\n  if (options.addClass) {\n    options.addClass.split(' ').forEach((x) => link.classList.add(x));\n  }\n\n  const onClick = (e: Event) => {\n    e.stopPropagation();\n    options.onClick();\n  };\n  if (options.onClick !== undefined) {\n    link.addEventListener('click', onClick);\n  }\n\n  return createControl(\n    {\n      onAdd() {\n        return link;\n      },\n      onRemove() {\n        const parent = link.parentNode;\n        if (parent) {\n          parent.removeChild(link);\n        }\n        if (options.onClick !== undefined) {\n          link.removeEventListener('click', onClick);\n        }\n      },\n    },\n    { bar: true, addClass: 'maplibregl-ctrl-group' },\n  );\n}\n","import { MainLayerAdapter, WmsAdapterOptions } from '@nextgis/webmap';\n\nimport { TileAdapter } from './TileAdapter';\n\nexport class WmsAdapter\n  extends TileAdapter<WmsAdapterOptions>\n  implements MainLayerAdapter\n{\n  addLayer(options: WmsAdapterOptions): string[] | undefined {\n    Object.assign(this.options, options);\n    const params: Record<string, string | number> = {\n      bbox: '{bbox-epsg-3857}',\n      format: options.format || 'image/png',\n      service: 'WMS',\n      version: '1.1.1',\n      request: 'GetMap',\n      srs: 'EPSG:3857',\n      transparent: 'true',\n      width: options.tileSize || '256',\n      height: options.tileSize || '256',\n      layers: options.layers || '',\n    };\n    const paramsStr = Object.keys(params)\n      .map((x) => `${x}=${params[x]}`)\n      .join('&');\n    options.url = options.url + '?' + paramsStr;\n    if (options.nativeOptions) {\n      Object.assign(options, this.options.nativeOptions);\n    }\n    return super.addLayer(options);\n  }\n}\n","import { NavigationControl } from 'maplibre-gl';\nimport type { ZoomControlOptions } from '@nextgis/webmap';\n\nexport function ZoomControl(options: ZoomControlOptions) {\n  return new NavigationControl({ ...options, showCompass: false });\n}\n","import { NavigationControl } from 'maplibre-gl';\n\nexport function CompassControl(options: Record<string, unknown>) {\n  return new NavigationControl({ ...options, showZoom: false });\n}\n","/**\n * @module mapboxgl-map-adapter\n */\n\nimport { MapboxglMapAdapter } from './MapboxglMapAdapter';\n\nimport type { MapboxglMapAdapterOptions } from './MapboxglMapAdapter';\n\nexport type { MapboxglMapAdapterOptions };\n\nexport default MapboxglMapAdapter;\n","/**\n * Thrown when...\n */\nexport class NetworkError extends Error {\n  name = 'NetworkError';\n\n  constructor(url: string) {\n    super();\n    Object.setPrototypeOf(this, NetworkError.prototype);\n    this.message = `Unable to request ${url}.\n    Possibly invalid NGW URL entered or CORS not configured to get request from ${location.origin}`; // /control-panel/cors\n  }\n}\n","import { NgwExceptions } from '../interfaces';\n\n/**\n * Thrown when...\n */\nexport class NgwError extends Error {\n  name = 'NgwError';\n\n  title!: string;\n  message!: string;\n  detail!: string;\n  exception!: NgwExceptions;\n  status_code!: number | 404 | 500;\n  data?: Record<string, any>;\n  guru_meditation!: string;\n\n  constructor(er?: Partial<NgwError>) {\n    super();\n    Object.assign(this, er);\n    Object.setPrototypeOf(this, NgwError.prototype);\n  }\n}\n","import {\n  RequestOptions as NgwRequestOptions,\n  RequestMethods,\n} from '../interfaces';\nimport { NetworkError } from '../errors/NetworkError';\nimport { NgwError } from '../errors/NgwError';\nimport { isError } from '../errors/isError';\nimport { isObject } from './isObject';\n\n// readyState\n// Holds the status of the XMLHttpRequest.\n// 0: request not initialized\n// 1: server connection established\n// 2: request received\n// 3: processing request\n// 4: request finished and response is ready\n\n// status\n// 200: \"OK\"\n// 201 \"Created\"\tThe request has been fulfilled, and a new resource is created\n// 403: \"Forbidden\"\n// 404: \"Page not found\"\n// 500: \"Internal Server Error\"\n// For a complete list go to the Http Messages Reference\n\ntype LoadData = (\n  url: string,\n  callback: (...args: any[]) => any,\n  options: NgwRequestOptions<RequestMethods> | undefined,\n  error: (reason?: any) => void,\n  onCancel: (cancelHandler: () => void) => void,\n) => void;\n\nlet loadData: LoadData;\n// @ts-ignore\nif (__BROWSER__) {\n  loadData = (\n    url: string,\n    callback: (...args: any[]) => any,\n    options: NgwRequestOptions = {},\n    error: (reason?: any) => void,\n    onCancel: (cancelHandler: () => void) => void,\n  ): void => {\n    options.method = options.method || 'GET';\n\n    const xhr = new XMLHttpRequest();\n    xhr.open(options.method || 'GET', url, true); // true for asynchronous\n\n    if (options.responseType === 'blob') {\n      xhr.responseType = options.responseType;\n    }\n    const getResponseText = () => {\n      try {\n        return JSON.parse(xhr.responseText);\n      } catch (er) {\n        return xhr.responseText;\n      }\n    };\n    const processingResponse = (forError = false) => {\n      const cb = forError ? error : callback;\n      if (options.responseType === 'blob') {\n        cb(xhr.response);\n      } else {\n        if (xhr.responseText) {\n          cb(getResponseText());\n        } else {\n          error({ message: '' });\n        }\n      }\n    };\n    xhr.onload = () => {\n      if ([401, 403, 404, 422, 500].indexOf(xhr.status) !== -1) {\n        error(new NgwError(getResponseText()));\n      }\n      processingResponse();\n    };\n\n    // xhr.onreadystatechange = () => {\n    //   if (\n    //     (xhr.readyState === 4 && xhr.status === 200) ||\n    //     (xhr.readyState === 3 && xhr.status === 201)\n    //   ) {\n    //     processingResponse();\n    //   } else if (xhr.readyState === 3 && xhr.status === 400) {\n    //     processingResponse();\n    //   } else if (xhr.readyState === 4 && xhr.status === 500) {\n    //     processingResponse();\n    //   } else if (xhr.readyState === 4 && xhr.status === 401) {\n    //     error(xhr.statusText);\n    //   } else if (xhr.readyState === 4) {\n    //     error('request error');\n    //   }\n    // };\n\n    xhr.onerror = (er) => {\n      if (xhr.status === 0) {\n        error(new NetworkError(url));\n      } else {\n        error(er);\n      }\n    };\n\n    xhr.upload.onprogress = function (e) {\n      if (e.lengthComputable) {\n        const percentComplete = (e.loaded / e.total) * 100;\n        if (options.onProgress) {\n          options.onProgress(percentComplete, e);\n        }\n        // console.log(percentComplete + '% uploaded');\n      }\n    };\n\n    const headers = options.headers;\n    if (headers) {\n      for (const h in headers) {\n        const header = headers[h];\n        if (typeof header === 'string') {\n          xhr.setRequestHeader(h, header);\n        }\n      }\n    }\n    if (options.withCredentials !== undefined) {\n      xhr.withCredentials = options.withCredentials;\n    }\n\n    let data: FormData | any;\n    if (options.file) {\n      data = new FormData();\n      data.append('file', options.file);\n      if (options.data) {\n        for (const d in options.data) {\n          data.append(d, data[d]);\n        }\n      }\n    } else {\n      data = options.data\n        ? typeof options.data === 'string'\n          ? options.data\n          : JSON.stringify(options.data)\n        : null;\n    }\n    if (onCancel) {\n      onCancel(() => {\n        xhr.abort();\n      });\n    }\n    xhr.send(data);\n  };\n} else {\n  const url = require('url');\n  const http = require('http');\n  const https = require('https');\n  const FormData = require('form-data');\n\n  const adapterFor = (inputUrl: string) => {\n    const adapters: Record<string, any> = {\n      'http:': http,\n      'https:': https,\n    };\n    const protocol = url.parse(inputUrl).protocol || 'https:';\n    return adapters[protocol];\n  };\n\n  loadData = (\n    url: string,\n    callback: (...args: any[]) => any,\n    options: NgwRequestOptions<RequestMethods> = {},\n    error: (reason?: any) => void,\n    onCancel: (cancelHandler: () => void) => void,\n  ): Promise<unknown> => {\n    const { file, headers, method, data, responseType } = options;\n\n    const request = new Promise((resolve, reject) => {\n      const adapter = adapterFor(url);\n      if (adapter) {\n        const requestOpt = {\n          headers: headers || {},\n          method,\n        };\n        const body = typeof data === 'string' ? data : JSON.stringify(data);\n        // https://stackoverflow.com/questions/35589109/node-http-delete-request-no-longer-works-after-upgrading-from-0-10-40\n        let form;\n        let uploadedFile = file;\n        if (file) {\n          const fileMeta = {};\n          if (\n            isObject(file) &&\n            'file' in file &&\n            ('filename' in file || 'name' in file)\n          ) {\n            const {\n              file: file_,\n              name,\n              ...fileMeta_\n            } = file as Record<string, any>;\n            if (name && !fileMeta_.filename) {\n              fileMeta_.filename = name;\n            }\n            Object.assign(fileMeta, fileMeta_);\n            uploadedFile = file_ as File;\n          }\n          form = new FormData();\n          form.append('file', uploadedFile, fileMeta);\n          if (data) {\n            for (const d in data) {\n              form.append(d, data[d]);\n            }\n          }\n          Object.assign(requestOpt.headers, {\n            // 'content-length': form.getLengthSync(),\n            ...form.getHeaders(),\n          });\n        }\n\n        if (body !== undefined) {\n          Object.assign(requestOpt.headers, {\n            'content-type': 'application/json',\n            'content-length': Buffer.byteLength(body),\n          });\n        }\n        const req = adapter.request(url, requestOpt, (resp: any) => {\n          let data = '';\n          resp.on('data', (chunk: any) => {\n            data += chunk;\n          });\n          resp.on('end', () => {\n            if (data) {\n              if (responseType === 'blob') {\n                resolve(data);\n              } else {\n                let json: Record<string, any> | undefined;\n                try {\n                  json = JSON.parse(data);\n                  if (json && json.status_code && json.status_code) {\n                    reject(json.message);\n                  }\n                } catch (er) {\n                  reject(er);\n                }\n                if (json !== undefined) {\n                  if (isError(json)) {\n                    reject('extractError(json)');\n                  } else {\n                    resolve(json);\n                  }\n                }\n              }\n            }\n            reject('no data');\n          });\n        });\n        if (form) {\n          form.pipe(req);\n        }\n        req.on('error', (err: any) => {\n          reject(err);\n        });\n        if (body) {\n          req.write(body);\n        }\n        onCancel(() => {\n          req.abort();\n        });\n        req.end();\n      } else {\n        throw new Error(`Given URL '${url}' is not correct`);\n      }\n    });\n    return request\n      .then((data) => {\n        if (callback) {\n          callback(data);\n        }\n        return data;\n      })\n      .catch((er) => {\n        if (error) {\n          error(er);\n        } else {\n          throw new Error(er);\n        }\n      });\n  };\n}\n\nexport { loadData };\n","// https://github.com/Leaflet/Leaflet/blob/b507e21c510b53cd704fb8d3f89bb46ea925c8eb/src/core/Util.js#L165\nconst templateRe = /\\{ *([\\w_-]+) *\\}/g;\n\nexport function template(str: string, data: { [param: string]: any }): string {\n  return str.replace(templateRe, (s, key) => {\n    let value = data[key];\n\n    if (value === undefined) {\n      throw new Error('No value provided for letiable ' + s);\n    } else if (typeof value === 'function') {\n      value = value(data);\n    }\n    return value;\n  });\n}\n","import { NgwError } from './NgwError';\nimport { NgwExceptions } from '../interfaces';\n\n/**\n * Thrown when ...\n */\nexport class ResourceNotFoundError extends NgwError {\n  name = 'ResourceNotFoundError';\n  exception: NgwExceptions = 'nextgisweb.resource.exception.ResourceNotFound';\n\n  constructor(obj?: ResourceNotFoundError) {\n    super(obj);\n    Object.setPrototypeOf(this, ResourceNotFoundError.prototype);\n  }\n}\n","import { NgwError } from './NgwError';\nimport { NgwExceptions } from '../interfaces';\n\n/**\n * Thrown when ...\n */\nexport class InsufficientPermissionsError extends NgwError {\n  name = 'InsufficientPermissionsError';\n  exception: NgwExceptions =\n    'nextgisweb.core.exception.InsufficientPermissions';\n\n  constructor(obj: InsufficientPermissionsError) {\n    super(obj);\n    Object.setPrototypeOf(this, InsufficientPermissionsError.prototype);\n  }\n}\n","import { NgwConnectorOptions } from './interfaces';\nimport { NgwConnector } from './NgwConnector';\nimport { objectDeepEqual } from '@nextgis/utils';\n\nexport const CONNECTORS: NgwConnector[] = [];\n\nexport function addConnector(connector: NgwConnector): void {\n  CONNECTORS.push(connector);\n}\n\nexport function findConnector(\n  options: NgwConnectorOptions,\n): NgwConnector | undefined {\n  return CONNECTORS.find((x) => {\n    if (x.options.baseUrl === options.baseUrl) {\n      if (options.auth) {\n        if (x.options.auth) {\n          return objectDeepEqual(x.options.auth, options.auth);\n        }\n      } else {\n        // if auth not in find options; use first connector with same url\n        return true;\n      }\n    }\n  });\n}\n\nexport function removeConnector(connector: NgwConnector): void {\n  const index = CONNECTORS.indexOf(connector);\n  if (index !== -1) {\n    CONNECTORS.splice(index, 1);\n  }\n}\n\nexport function findAndRemoveConnector(options: NgwConnectorOptions): void {\n  const exist = findConnector(options);\n  if (exist) {\n    removeConnector(exist);\n  }\n}\n","export function isObject(val: unknown): val is Record<string | number, any> {\n  return Object.prototype.toString.call(val) === '[object Object]';\n}\n","import { DeepPartial, defined } from '@nextgis/utils';\nimport { Resource } from '../types/ResourceItem';\nimport { isObject } from './isObject';\n\nconst exclude = ['description'];\n\n/**\n * @remarks\n * https://docs.nextgis.ru/docs_ngweb_dev/doc/developer/resource.html#search-resources\n *\n * ```\n * { keyname, owner_user: { id }} > { keyname, owner_user__id }\n * ```\n *\n * @param resource - Any property from NGW resource item\n */\nexport function resourceToQuery(\n  resource: DeepPartial<Resource>,\n  prefix = '',\n): Record<string, unknown> {\n  prefix = prefix ? prefix + '__' : '';\n  const query: Record<string, any> = {};\n  for (const [key, value] of Object.entries(resource)) {\n    if (exclude.indexOf(key) === -1) {\n      if (isObject(value)) {\n        if (key === 'owner_user') {\n          const children = resourceToQuery(value as DeepPartial<Resource>, key);\n          Object.assign(query, children);\n        } else if (key === 'parent' && 'id' in value) {\n          query.parent_id = value.id;\n        }\n      } else if (defined(value)) {\n        query[prefix + key] = value;\n      }\n    }\n  }\n  return query;\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport { defined } from '@nextgis/utils';\nimport Cache from '@nextgis/cache';\n\nimport { resourceToQuery } from './utils/resourceToQuery';\nimport { resourceCompare } from './utils/resourceCompare';\nimport { ResourceNotFoundError } from './errors/ResourceNotFoundError';\n\nimport { isObject } from './utils/isObject';\n\nimport type { DeepPartial } from '@nextgis/utils';\nimport type { NgwConnector } from './NgwConnector';\nimport type { ResourceItem, Resource } from './types/ResourceItem';\nimport type {\n  GetChildrenOfOptions,\n  ResourceDefinition,\n  RequestOptions,\n} from './interfaces';\n\nexport class ResourcesControl {\n  cache = new Cache<\n    CancelablePromise<ResourceItem | undefined>,\n    { id?: number | string }\n  >();\n\n  constructor(private connector: NgwConnector) {}\n\n  // -------------------------------------------------------------------------\n  // Resource Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Receive resource from NGW by id, keyname or search-object parameter.\n   * @param resource - Resource id, keyname or search-object\n   *\n   * @remarks\n   * Fetching resource would be cached to speed up next call\n   */\n  getOne(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem | undefined> {\n    const cache = new Cache();\n    const forCache: { keyname?: string; id?: number } = {};\n    const opt = { ...requestOptions, cache: false };\n    if (typeof resource === 'string') {\n      forCache.keyname = resource;\n    } else if (typeof resource === 'number') {\n      forCache.id = resource;\n    } else if (isObject(resource)) {\n      if (resource.id !== undefined) {\n        forCache.id = resource.id;\n      } else if (resource.keyname) {\n        forCache.keyname = resource.keyname;\n      }\n    }\n    const makeRequest = () => {\n      if (typeof resource === 'string') {\n        return this._fetchResourceBy({ keyname: resource }, opt);\n      } else if (typeof resource === 'number') {\n        return this._fetchResourceById(resource, opt);\n      } else if (isObject(resource)) {\n        return this._fetchResourceBy(resource, opt);\n      }\n      return CancelablePromise.resolve(undefined);\n    };\n\n    return cache.addFull('resource', makeRequest, forCache);\n  }\n\n  getOneOrFail(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem> {\n    return this.getOne(resource, requestOptions).then((res) => {\n      if (res) {\n        return res;\n      }\n      throw new ResourceNotFoundError();\n    });\n  }\n\n  /**\n   * A fast way to retrieve resource ID for any resource definition.\n   * @param resource - Any available resource definition\n   *\n   * @remarks\n   * There are situations when exactly the resource id is needed\n   * (for example, to compose the correct request to the api)\n   * then this method will come in handy to facilitate the extraction of the identifier\n   * if the resource is specified through a keyname or other parameters.\n   */\n  getId(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<number | undefined> {\n    if (typeof resource === 'number') {\n      return CancelablePromise.resolve(resource);\n    } else if (typeof resource === 'string' || isObject(resource)) {\n      return this.getOne(resource, requestOptions).then((res) => {\n        if (res) {\n          return res.resource.id;\n        }\n      });\n    }\n    return CancelablePromise.resolve(undefined);\n  }\n\n  /**\n   * A fast way to retrieve resource ID for any resource definition.\n   * @param resource - Any available resource definition\n   *\n   * @remarks\n   * Similar with {@link NgwConnector.getResourceId | getResourceId} but rise error if resource is not exist.\n   * To not make one more checks if the resource is definitely exists\n   */\n  getIdOrFail(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<number> {\n    return this.getId(resource, requestOptions).then((resp) => {\n      if (resp === undefined) {\n        throw new Error();\n      }\n      return resp;\n    });\n  }\n\n  getMany(\n    resource: DeepPartial<Resource>,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem[]> {\n    return this._resourceCacheFilter(resource).then((items) => {\n      if (!items.length) {\n        const query: Record<string, unknown> = {};\n        if (resource.keyname) {\n          query.keyname = resource.keyname;\n        } else {\n          Object.assign(query, resourceToQuery(resource));\n        }\n        return this.connector\n          .get('resource.search', requestOptions, {\n            serialization: 'full',\n            ...query,\n          })\n          .then((resources) => {\n            if (resources) {\n              for (const x of resources) {\n                this.cache.add('resource.item', CancelablePromise.resolve(x), {\n                  id: x.resource.id,\n                });\n              }\n            }\n            return resources;\n          });\n      }\n      return items;\n    });\n  }\n\n  getParent(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.getOne(resource, requestOptions).then((child) => {\n      if (child) {\n        return this.getOne(child.resource.parent.id, requestOptions);\n      }\n      return CancelablePromise.resolve(undefined);\n    });\n  }\n\n  getChildrenOf(\n    resource: ResourceDefinition,\n    requestOptions?: GetChildrenOfOptions,\n  ): CancelablePromise<ResourceItem[]> {\n    return this.getIdOrFail(resource).then((parent) =>\n      this._getChildrenOf(parent, requestOptions),\n    );\n  }\n\n  private _getChildrenOf(\n    parent: ResourceDefinition,\n    requestOptions?: GetChildrenOfOptions,\n    _items: ResourceItem[] = [],\n  ): CancelablePromise<ResourceItem[]> {\n    return this.connector\n      .get(\n        'resource.collection',\n        { cache: true, ...requestOptions },\n        {\n          parent,\n        },\n      )\n      .then((items) => {\n        const recursivePromises = [];\n        for (const item of items) {\n          this.cache.add('resource.item', CancelablePromise.resolve(item), {\n            id: item.resource.id,\n          });\n          _items.push(item);\n          if (requestOptions?.recursive && item.resource.children) {\n            recursivePromises.push(\n              this._getChildrenOf(item.resource.id, requestOptions, _items),\n            );\n          }\n        }\n        if (recursivePromises.length) {\n          return CancelablePromise.all(recursivePromises).then(() => {\n            return _items;\n          });\n        }\n        return _items;\n      });\n  }\n\n  update(\n    resource: ResourceDefinition,\n    data: DeepPartial<ResourceItem>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.getId(resource).then((id) => {\n      if (id !== undefined) {\n        return this.connector.put('resource.item', { data }, { id });\n      }\n    });\n  }\n\n  /**\n   * Fast way to delete resource from NGW and clean cache.\n   * @param resource - Resource definition\n   */\n  delete(resource: ResourceDefinition): CancelablePromise<void> {\n    return this.getId(resource).then((id) => {\n      if (id !== undefined) {\n        return this.connector.delete('resource.item', null, { id }).then(() => {\n          this._cleanResourceItemCache(id);\n          return undefined;\n        });\n      }\n    });\n  }\n\n  private async _cleanResourceItemCache(id: number) {\n    const all = this.cache.all();\n    const toDelete: typeof all = [];\n    for (const c of all) {\n      const cid = c.options && c.options.id;\n      if (['resource.item', 'resource'].includes(c.key) && cid !== undefined) {\n        if (typeof cid === 'number') {\n          if (cid === id) {\n            toDelete.push(c);\n          }\n        } else {\n          const rid = await this.getId(cid);\n          if (rid === id) {\n            toDelete.push(c);\n          }\n        }\n      }\n    }\n    for (const d of toDelete) {\n      this.cache.delete(d);\n    }\n  }\n\n  private _fetchResourceById(\n    id: number,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem | undefined> {\n    const promise = () =>\n      this.connector.get('resource.item', requestOptions, { id });\n\n    return this.cache\n      .add('resource.item', promise, {\n        id,\n      })\n      .catch((er) => {\n        if (!(er instanceof ResourceNotFoundError)) {\n          throw er;\n        }\n        return undefined;\n      });\n  }\n\n  private _fetchResourceBy(\n    resource: DeepPartial<Resource>,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.getMany(resource, requestOptions).then((resources) => {\n      return resources[0];\n    });\n  }\n\n  private _resourceCacheFilter(\n    resource: DeepPartial<Resource>,\n  ): CancelablePromise<ResourceItem[]> {\n    return CancelablePromise.all(this.cache.matchAll('resource.item')).then(\n      (resources) => {\n        const items: ResourceItem[] = [];\n        resources.filter((x) => {\n          if (x) {\n            // identical by uniq props\n            if (resource.keyname && x.resource.keyname) {\n              return resource.keyname === x.resource.keyname;\n            }\n            if (defined(resource.id) && defined(x.resource.id)) {\n              return resource.id === x.resource.id;\n            }\n            return resourceCompare(resource, x.resource);\n          }\n        });\n        return items;\n      },\n    );\n  }\n}\n","import { objectDeepEqual } from '@nextgis/utils';\nimport type { DeepPartial } from '@nextgis/utils';\nimport type { Resource } from '../types/ResourceItem';\n\nexport function resourceCompare(\n  res1: DeepPartial<Resource>,\n  res2: DeepPartial<Resource>,\n): boolean {\n  return objectDeepEqual(res1, res2);\n}\n","import { EventEmitter } from 'events';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { objectRemoveEmpty } from '@nextgis/utils';\nimport { fixUrlStr } from '@nextgis/utils';\nimport Cache from '@nextgis/cache';\n\nimport { loadData } from './utils/loadData';\nimport { template } from './utils/template';\nimport { NgwError } from './errors/NgwError';\nimport { ResourceNotFoundError } from './errors/ResourceNotFoundError';\nimport { InsufficientPermissionsError } from './errors/InsufficientPermissionsError';\nimport {\n  addConnector,\n  findConnector,\n  removeConnector,\n} from './activeConnectors';\nimport { ResourcesControl } from './ResourcesControl';\n\nimport type { DeepPartial } from '@nextgis/utils';\nimport type {\n  DeleteRequestItemsResponseMap,\n  PatchRequestItemsResponseMap,\n  PostRequestItemsResponseMap,\n  GetRequestItemsResponseMap,\n  PutRequestItemsResponseMap,\n  GetChildrenOfOptions,\n  ResourceIdKeynameDef,\n  NgwConnectorOptions,\n  ResourceDefinition,\n  RequestItemsParams,\n  RequestItemKeys,\n  RequestHeaders,\n  RequestOptions,\n  PyramidRoute,\n  Credentials,\n  UserInfo,\n  Params,\n} from './interfaces';\nimport type { RequestItemsParamsMap } from './types/RequestItemsParamsMap';\nimport type { ResourceItem, Resource } from './types/ResourceItem';\nimport { apiRequest } from './utils/apiRequest';\n\nlet ID = 0;\n\nexport class NgwConnector {\n  static errors = {\n    NgwError,\n    ResourceNotFoundError,\n  };\n  id = ID++;\n\n  emitter = new EventEmitter();\n  user?: UserInfo;\n\n  resources!: ResourcesControl;\n\n  private routeStr = '/api/component/pyramid/route';\n  private activeRequests: CancelablePromise[] = [];\n\n  constructor(public options: NgwConnectorOptions) {\n    const exist = findConnector(options);\n    if (exist) {\n      return exist;\n    } else {\n      if (this.options.route) {\n        this.routeStr = this.options.route;\n      }\n      this.resources = new ResourcesControl(this);\n      addConnector(this);\n    }\n  }\n\n  static create(options: NgwConnectorOptions): NgwConnector {\n    return new this(options);\n  }\n\n  /**\n   * Fast way to specify the connection address to NextGIS Web.\n   * The current connection will be severed.\n   * @param baseUrl - NGW url\n   */\n  setNgw(baseUrl: string): void {\n    this.logout();\n    this.options.baseUrl = baseUrl;\n    addConnector(this);\n  }\n\n  /**\n   * Establishing a connection with NextGIS Web to fulfill all other requests.\n   * @remarks\n   * This method need not be called manually as it is used when forming a request in {@link NgwConnector.apiRequest | apiRequest}.\n   * Can be used to check connection.\n   * @example\n   * ```javascript\n   * const connector = new NgwConnector({baseUrl: 'https://demo.nextgis.com'});\n   * connector.connect()\n   *   .then(() => console.log('Ok'))\n   *   .catch((er) => console.log('Connection problem', er));\n   * ```\n   */\n  connect(): CancelablePromise<PyramidRoute> {\n    const cache = new Cache();\n    const auth = this.options.auth;\n    const makeConnect = () =>\n      new CancelablePromise((resolve, reject) => {\n        const makeQuery = () => {\n          return this.makeQuery<PyramidRoute>(this.routeStr, {}, {})\n            .then((route) => {\n              resolve(route);\n            })\n            .catch((er) => {\n              reject(er);\n            });\n        };\n        if (auth) {\n          const { login, password } = auth;\n          if (login && password) {\n            return this.getUserInfo({ login, password })\n              .then(() => {\n                makeQuery();\n              })\n              .catch((er) => reject(er));\n          }\n        }\n        return makeQuery();\n      });\n    return cache.add('route', makeConnect, {\n      id: this.id,\n      auth,\n      baseUrl: this.options.baseUrl,\n    });\n  }\n\n  /**\n   * Quick way to change NextGIS Web user.\n   * @param credentials - New user credentials\n   */\n  login(credentials: Credentials): CancelablePromise<UserInfo> {\n    this.logout();\n    addConnector(this);\n    return this.getUserInfo(credentials);\n  }\n\n  /**\n   * Disconnecting a user. Aborting all current requests\n   */\n  logout(): void {\n    this.abort();\n    removeConnector(this);\n    this.options.auth = undefined;\n    this.user = undefined;\n    this.emitter.emit('logout');\n    this.resources.cache.clean();\n  }\n\n  getUserInfo(credentials?: Credentials): CancelablePromise<UserInfo> {\n    if (this.user && this.user.id) {\n      return CancelablePromise.resolve(this.user);\n    }\n    if (credentials) {\n      this.options.auth = credentials;\n    }\n    const options: RequestOptions = {\n      headers: this.getAuthorizationHeaders(credentials),\n      // withCredentials: true\n    };\n\n    // Do not use apiRequest('auth.current_user') to avoid circular-references\n    return this.makeQuery<UserInfo>(\n      '/api/component/auth/current_user',\n      {},\n      options,\n    )\n      .then((data) => {\n        this.user = data;\n        this.emitter.emit('login', data);\n        return data;\n      })\n      .catch((er) => {\n        this.emitter.emit('login:error', er);\n        throw er;\n      });\n  }\n\n  /**\n   * Obtaining the required Headers for authentication of requests in the NGW.\n   */\n  getAuthorizationHeaders(\n    credentials?: Credentials,\n  ): RequestHeaders | undefined {\n    const client = this.makeClientId(credentials);\n    if (client) {\n      return {\n        Authorization: 'Basic ' + client,\n      };\n    }\n  }\n\n  makeClientId(credentials?: Credentials): string | undefined {\n    credentials = credentials || this.options.auth;\n    if (credentials) {\n      const { login, password } = credentials;\n      const str = unescape(encodeURIComponent(`${login}:${password}`));\n      // @ts-ignore\n      if (__BROWSER__) {\n        return window.btoa(str);\n      } else {\n        return Buffer.from(str).toString('base64');\n      }\n    }\n  }\n\n  /** Stop all api requests */\n  abort() {\n    for (const req of this.activeRequests) {\n      req.cancel();\n    }\n    this.activeRequests = [];\n  }\n\n  getActiveApiRequests() {\n    return [...this.activeRequests];\n  }\n\n  /**\n   * Send request to NGW api router.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param params - Request item params or query params\n   * @param requestOptions - Request options\n   *\n   * @example\n   * ```javascript\n   *\n   * // there is such an NGW route item\n   * // \"feature_layer.feature.item\": [\n   * //   \"/api/resource/{0}/feature/{1}\",\n   * //   \"id\",\n   * //   \"fid\"\n   * // ],\n   *\n   * const connector = new NgwConnector({ baseUrl: 'https://example.nextgis.com' });\n   * connector.apiRequest('feature_layer.feature.item', {\n   *   // request params for {0} and {1}\n   *   'id': 2011,\n   *   'fid': 101,\n   *   // query params\n   *   'srs': 4326,\n   *   'geom_format': 'geojson',\n   * }, { method: 'GET' });\n   * // send get-request to 'https://example.nextgis.com/api/resource/2011/feature/101?srs=4326&geom_format=geojson'\n   *\n   * ```\n   */\n  apiRequest<\n    K extends keyof RequestItemsParamsMap,\n    P extends RequestItemKeys = RequestItemKeys,\n  >(\n    name: K,\n    params_: RequestItemsParams<K> = {},\n    requestOptions: RequestOptions = {},\n  ): CancelablePromise<P[K]> {\n    const { method, headers, withCredentials, responseType } = requestOptions;\n    const params = objectRemoveEmpty(params_);\n    const makeApiRequest = () =>\n      apiRequest({ name, params, requestOptions, connector: this });\n    if (requestOptions.cache && method === 'GET') {\n      const cache = new Cache<CancelablePromise<P[K]>>();\n      return cache.add(name, makeApiRequest, {\n        params,\n        ...objectRemoveEmpty({\n          headers,\n          withCredentials,\n          responseType,\n          baseUrl: this.options.baseUrl,\n          auth: this.options.auth,\n        }),\n      });\n    }\n    return makeApiRequest();\n  }\n\n  /**\n   * Shortcut method for send POST request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   *\n   * @example\n   * ```javascript\n   * connector.post('resource.collection', { data: POST_PAYLOAD })\n   *   .then((newResource) => console.log(newResource))\n   *   .catch((error) => console.warn(error));\n   * ```\n   */\n  post<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions<'POST'>,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<PostRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'POST';\n    return this.apiRequest<K, PostRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Shortcut method for send GET request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   */\n  get<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions | undefined | null,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<GetRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'GET';\n    return this.apiRequest<K, GetRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Shortcut method for send PATCH request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   */\n  patch<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<PatchRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PATCH';\n    return this.apiRequest<K, PatchRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Shortcut method for send PUT request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   */\n  put<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<PutRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PUT';\n    return this.apiRequest<K, PutRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Shortcut method for send DELETE request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   */\n  delete<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions | undefined | null,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<DeleteRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'DELETE';\n    return this.apiRequest<K, DeleteRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Send request to NGW.\n   * @param url - URL address to NGW\n   * @param params - Query params\n   * @param options - Request options\n   */\n  makeQuery<R = unknown>(\n    url: string,\n    params?: Params | null,\n    options: RequestOptions = {},\n  ): CancelablePromise<R> {\n    url = (this.options.baseUrl ? this.options.baseUrl : '') + url;\n    if (url) {\n      if (params) {\n        url = template(url, params);\n      }\n      // remove double slash\n      url = fixUrlStr(url);\n      return this._loadData(encodeURI(url), options);\n    } else {\n      throw new Error('Empty `url` not allowed');\n    }\n  }\n\n  // -------------------------------------------------------------------------\n  // Resource Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * {@inheritDoc ResourcesControl.getOne}\n   */\n  getResource(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getOne(resource, requestOptions);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getOneOrFail}\n   */\n  getResourceOrFail(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem> {\n    return this.resources.getOneOrFail(resource, requestOptions);\n  }\n\n  /**\n   * @deprecated - use {@link NgwConnector.getResource}\n   */\n  getResourceBy(\n    resource: DeepPartial<Resource>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getOne(resource);\n  }\n\n  /**\n   * @deprecated - use {@link NgwConnector.getResource}\n   */\n  getResourceByKeyname(\n    keyname: string,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getOne(keyname);\n  }\n\n  /**\n   * @deprecated - use {@link NgwConnector.getResource}\n   */\n  getResourceById(id: number): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getOne(id);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getId}\n   */\n  getResourceId(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<number | undefined> {\n    return this.resources.getId(resource, requestOptions);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getIdOrFail}\n   */\n  getResourceIdOrFail(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<number> {\n    return this.resources.getIdOrFail(resource, requestOptions);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getMany}\n   */\n  getResourcesBy(\n    resource: DeepPartial<Resource>,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem[]> {\n    return this.resources.getMany(resource, requestOptions);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getParent}\n   */\n  getResourceParent(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getParent(resource, requestOptions);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getChildrenOf}\n   */\n  getResourceChildren(\n    resource: ResourceDefinition,\n    requestOptions?: GetChildrenOfOptions,\n  ): CancelablePromise<ResourceItem[]> {\n    return this.resources.getChildrenOf(resource, requestOptions);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.update}\n   */\n  updateResource(\n    resource: ResourceIdKeynameDef,\n    data: DeepPartial<ResourceItem>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.update(resource, data);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.delete}\n   */\n  deleteResource(resource: ResourceIdKeynameDef): CancelablePromise<void> {\n    return this.resources.delete(resource);\n  }\n\n  /**\n   * @internal\n   */\n  protected _loadData(\n    url: string,\n    options: RequestOptions,\n  ): CancelablePromise<any> {\n    options.responseType = options.responseType || 'json';\n\n    const request = new CancelablePromise((resolve, reject, onCancel) => {\n      if (this.user) {\n        options = options || {};\n        // options.withCredentials = true;\n        options.headers = {\n          ...this.getAuthorizationHeaders(),\n          ...options.headers,\n        };\n      }\n      loadData(url, resolve, options, reject, onCancel);\n    })\n      .then((resp) => {\n        this._cleanActiveRequests(request);\n        return resp;\n      })\n      .catch((httpError) => {\n        this._cleanActiveRequests(request);\n        if (httpError instanceof CancelablePromise.CancelError) {\n          // not need to handle cancel error because onCancel method is used\n        } else {\n          // @ts-ignore\n          if (__DEV__) {\n            console.warn('DEV WARN', httpError);\n          }\n          const er = this._handleHttpError(httpError);\n          if (er) {\n            throw er;\n          }\n        }\n      });\n    if (\n      options.signal &&\n      typeof options.signal.addEventListener === 'function'\n    ) {\n      options.signal.addEventListener('abort', () => {\n        request.cancel();\n      });\n    }\n    this.activeRequests.push(request);\n    return request;\n  }\n\n  private _cleanActiveRequests(request: CancelablePromise) {\n    const activeRequestIndex = this.activeRequests.indexOf(request);\n    if (activeRequestIndex !== -1) {\n      this.activeRequests.splice(activeRequestIndex, 1);\n    }\n  }\n\n  private _handleHttpError(er: Error) {\n    if (er) {\n      if (er instanceof NgwError) {\n        if (er.exception === 'nextgisweb.resource.exception.ResourceNotFound') {\n          throw new ResourceNotFoundError(er);\n        } else if (\n          er.exception === 'nextgisweb.core.exception.InsufficientPermissions'\n        ) {\n          throw new InsufficientPermissionsError(er);\n        }\n      }\n    }\n    return er;\n  }\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport { template } from './template';\nimport type { NgwConnector } from '../NgwConnector';\nimport type {\n  RequestItemKeys,\n  RequestItemsParams,\n  RequestOptions,\n} from '../interfaces';\nimport type { RequestItemsParamsMap } from '../types/RequestItemsParamsMap';\n\ninterface ApiRequestOptions<K extends keyof RequestItemsParamsMap> {\n  name: string;\n  connector: NgwConnector;\n  params: RequestItemsParams<K>;\n  requestOptions: RequestOptions;\n}\n\nexport function apiRequest<\n  K extends keyof RequestItemsParamsMap,\n  P extends RequestItemKeys = RequestItemKeys,\n>(opt: ApiRequestOptions<K>): CancelablePromise<P[K]> {\n  const params = opt.params;\n  return new CancelablePromise((resolve, reject) => {\n    opt.connector\n      .connect()\n      .then((apiItems) => {\n        let apiItem = apiItems && apiItems[opt.name];\n        if (apiItem) {\n          apiItem = [...apiItem];\n          let url = apiItem.shift();\n          if (apiItem.length) {\n            const replaceParams: {\n              [num: number]: string;\n            } = {};\n            for (let fry = 0; fry < apiItem.length; fry++) {\n              const arg = apiItem[fry];\n              replaceParams[fry] = '{' + arg + '}';\n              if (params[arg] === undefined) {\n                throw new Error(\n                  '`' + arg + '`' + ' url api argument is not specified',\n                );\n              }\n            }\n            if (url) {\n              url = template(url, replaceParams);\n            }\n          }\n          // Transfer part of the parameters from `params` to the URL string\n          if (params) {\n            const paramArray = [];\n            const paramList = params.paramList;\n            if (Array.isArray(paramList)) {\n              delete params.paramList;\n              paramList.forEach((x) => {\n                paramArray.push(`${x[0]}=${x[1]}`);\n              });\n            }\n            for (const p in params) {\n              if (apiItem.indexOf(p) === -1) {\n                paramArray.push(`${p}=${params[p]}`);\n              }\n            }\n            if (paramArray.length) {\n              url = url + '?' + paramArray.join('&');\n            }\n          }\n          if (url) {\n            resolve(opt.connector.makeQuery(url, params, opt.requestOptions));\n          } else {\n            reject(new Error('request url is not set'));\n          }\n        } else {\n          resolve(undefined);\n        }\n      })\n      .catch((er) => {\n        reject(er);\n      });\n  });\n}\n","/**\n * A lightweight HTTP client optimized for use with {@link http://docs.nextgis.ru/docs_ngweb_dev/doc/developer/toc.html | NextGIS Web} API\n *\n * @remarks\n * Make sure CORS is registered in the {@link https://docs.nextgis.com/docs_ngcom/source/CORS.html | NextGIS Web settings } to be able to send requests.\n *\n * @packageDocumentation\n * @module ngw-connector\n */\nimport { NgwConnector } from './NgwConnector';\n\nexport * from './interfaces';\nexport * from './types/ResourceItem';\nexport * from './types/FeatureLayer';\nexport * from './types/RequestItemsParamsMap';\nexport * from './types/ResourceStore';\n\n// export { NgwConnector };\nexport default NgwConnector;\n","import type {\n  VectorAdapterLayerPaint,\n  GetPaintCallback,\n  PropertiesPaint,\n  GeometryPaint,\n  Expression,\n  IconPaint,\n  Paint,\n} from './interfaces';\n\nexport function isExpression(value: unknown): value is Expression {\n  if (Array.isArray(value)) {\n    return true;\n  }\n  return false;\n}\n\nexport function isPropertiesPaint(paint: Paint): paint is PropertiesPaint {\n  if (Array.isArray(paint)) {\n    return true;\n  }\n  return false;\n}\n\nexport function isPaint(paint: Paint): paint is VectorAdapterLayerPaint {\n  if (Object.prototype.toString.call(paint) === '[object Object]') {\n    return true;\n  }\n  return false;\n}\n\nexport function isBasePaint(paint: Paint): paint is GeometryPaint {\n  if (isPaint(paint)) {\n    if (paint.type === 'get-paint' || paint.type === 'icon') {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\nexport function isPaintCallback(paint: Paint): paint is GetPaintCallback {\n  if (typeof paint === 'function') {\n    return true;\n  }\n  return false;\n}\n\nexport function isIcon(paint: IconPaint): paint is IconPaint {\n  return paint.type === 'icon' || 'html' in paint;\n}\n","import { isExpression } from './typeHelpers';\n\nimport type { Feature } from 'geojson';\nimport type {\n  VectorAdapterLayerPaint,\n  GetPaintCallback,\n  Expression,\n  ExpressionName,\n} from './interfaces';\n\ntype ExpressionFun = (feature: Feature, args: any[]) => SimpleType;\n\nfunction get(feature: Feature, args: any[]) {\n  const field = args[0];\n  return feature.properties && feature.properties[field];\n}\n\nfunction match(feature: Feature, args: any[]) {\n  const [lookup, ...cases] = args;\n  let property = lookup;\n  if (Array.isArray(lookup)) {\n    property = featureExpression(feature, lookup as Expression);\n  }\n  // remove last odd item from cases array\n  const defValue = cases.splice(-1, cases.length % 2)[0];\n  for (let fry = 0; fry < cases.length - 1; fry += 2) {\n    const key = cases[fry];\n    if (key === property) {\n      return cases[fry + 1];\n    }\n  }\n  return defValue;\n}\n\nconst expressions: { [key in ExpressionName]: ExpressionFun } = {\n  get,\n  match,\n};\n\ntype SimpleType = string | number | boolean | undefined;\n\ntype PropertyExpressionCb = (feature: Feature) => SimpleType;\n\nfunction featureExpression(feature: Feature, expression: Expression) {\n  const [name, ...args] = expression;\n  const expressionFun = expressions[name];\n  if (expressionFun) {\n    return expressionFun(feature, args);\n  }\n  return undefined;\n}\n\nfunction createPropertyExpressionCb(\n  expression: Expression,\n): PropertyExpressionCb {\n  return (feature: Feature) => {\n    return featureExpression(feature, expression);\n  };\n}\n\nconst excludeExpressionList = ['iconSize', 'iconAnchor'];\n\nexport function createExpressionCallback(\n  paint: VectorAdapterLayerPaint,\n): GetPaintCallback | undefined {\n  let withExpression = false;\n  const expressions: {\n    [key: string]: PropertyExpressionCb;\n  } = {};\n  for (const p in paint) {\n    if (excludeExpressionList.indexOf(p) === -1) {\n      const p_ = p as keyof VectorAdapterLayerPaint;\n      const val = paint[p_];\n      if (isExpression(val)) {\n        withExpression = true;\n        expressions[p_] = createPropertyExpressionCb(val);\n      }\n    }\n  }\n  if (withExpression) {\n    return (feature: Feature) => {\n      const fromCb: any = {};\n      for (const p in expressions) {\n        fromCb[p] = expressions[p](feature);\n      }\n      return { ...paint, ...fromCb };\n    };\n  }\n  return;\n}\n","import { featureFilter } from '@nextgis/properties-filter';\n\nimport { createExpressionCallback } from './fromPaintExpression';\nimport { isPaintCallback, isPropertiesPaint } from './typeHelpers';\n\nimport type { Feature } from 'geojson';\nimport type {\n  Paint,\n  PropertyPaint,\n  GeometryPaint,\n  PropertiesPaint,\n  GetPaintCallback,\n  GetPaintFunction,\n  GetCustomPaintOptions,\n  VectorAdapterLayerPaint,\n} from './interfaces';\n\nfunction updatePaintOptionFromCallback(\n  paint: GetCustomPaintOptions,\n  getPaintFunctions?: { [name: string]: GetPaintFunction },\n): VectorAdapterLayerPaint | undefined {\n  if (typeof paint.from === 'function') {\n    return paint.from(paint.options);\n  } else if (typeof paint.from === 'string' && getPaintFunctions) {\n    const from = getPaintFunctions[paint.from];\n    if (from) {\n      return from(paint.options);\n    }\n  }\n}\n\nfunction createPropertiesPaint(\n  propertiesPaint: PropertiesPaint,\n): GetPaintFunction {\n  let mask: VectorAdapterLayerPaint = {};\n  const paintsFilters: PropertyPaint[] = [];\n  for (const p of propertiesPaint) {\n    if (p) {\n      if (Array.isArray(p)) {\n        paintsFilters.push(p);\n      } else {\n        mask = p as VectorAdapterLayerPaint;\n      }\n    }\n  }\n\n  return (feature: Feature) => {\n    const paint = paintsFilters.find((x) => featureFilter(feature, x[0]));\n    if (paint) {\n      return { ...mask, ...paint[1] };\n    }\n    return mask;\n  };\n}\n\nexport function preparePaint(\n  paint: Paint,\n  defaultPaint?: GeometryPaint,\n  getPaintFunctions?: { [name: string]: GetPaintFunction },\n): Paint {\n  if (!paint) {\n    throw new Error('paint is empty');\n  }\n  let newPaint: Paint = { ...defaultPaint };\n  if (isPaintCallback(paint)) {\n    const getPaintFunction: GetPaintCallback = (feature: Feature) => {\n      const getPaint = preparePaint(\n        paint(feature),\n        defaultPaint,\n        getPaintFunctions,\n      ) as VectorAdapterLayerPaint;\n      getPaint.type = paint.type;\n      return getPaint;\n    };\n    getPaintFunction.type = paint.type;\n    return getPaintFunction;\n  } else if (isPropertiesPaint(paint)) {\n    return (feature: Feature) => {\n      return preparePaint(\n        createPropertiesPaint(paint)(feature),\n        defaultPaint,\n        getPaintFunctions,\n      ) as VectorAdapterLayerPaint;\n    };\n  } else if (paint.type === 'get-paint') {\n    const getPaint = updatePaintOptionFromCallback(paint, getPaintFunctions);\n    if (getPaint) {\n      newPaint = preparePaint(getPaint, defaultPaint, getPaintFunctions);\n    }\n  } else if (paint.type === 'icon') {\n    return paint;\n  } else {\n    const expressionCallback = createExpressionCallback(paint);\n    if (expressionCallback) {\n      const expressionPaintCb = (feature: Feature) => {\n        return preparePaint(\n          expressionCallback(feature),\n          defaultPaint,\n          getPaintFunctions,\n        ) as VectorAdapterLayerPaint;\n      };\n      expressionPaintCb.paint = paint;\n      return expressionPaintCb;\n    }\n\n    newPaint = { ...newPaint, ...paint };\n    newPaint.fill = newPaint.fill !== undefined ? newPaint.fill : true;\n    newPaint.stroke =\n      newPaint.stroke !== undefined\n        ? newPaint.stroke\n        : !newPaint.fill || !!(newPaint.strokeColor || newPaint.strokeOpacity);\n  }\n\n  if (isPaintCallback(newPaint)) {\n    return newPaint;\n  }\n\n  if ('color' in newPaint) {\n    if (!newPaint.strokeColor) {\n      newPaint.strokeColor = newPaint.color;\n    }\n    if (!newPaint.fillColor) {\n      newPaint.fillColor = newPaint.color;\n    }\n  }\n  if ('opacity' in newPaint) {\n    if (newPaint.strokeOpacity === undefined) {\n      newPaint.strokeOpacity = newPaint.opacity;\n    }\n    if (newPaint.fillOpacity === undefined) {\n      newPaint.fillOpacity = newPaint.opacity;\n    }\n  }\n\n  return newPaint;\n}\n","import type { Feature } from 'geojson';\nimport type {\n  Operations,\n  Properties,\n  PropertiesFilter,\n  PropertyFilter,\n} from './interfaces';\n\nfunction reEscape(s: string): string {\n  return s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\nfunction like(b: string, a: string, iLike?: boolean): boolean {\n  a = String(a);\n  b = String(b);\n  if (a === b) return true;\n  if (iLike && a.toUpperCase() === b.toUpperCase()) return true;\n  const re = `^${reEscape(a)}$`.replace(/%/g, '.*').replace('_', '.');\n  return new RegExp(re, iLike ? 'i' : '').exec(b) !== null;\n}\n\nexport const operationsAliases: {\n  [key in Operations]: (a: any, b: any) => boolean;\n} = {\n  // greater(>)\n  gt: (a: any, b: any) => a > b,\n  // lower(<)\n  lt: (a: any, b: any) => a < b,\n  // greater or equal(>=)\n  ge: (a: any, b: any) => a >= b,\n  // lower or equal(<=)\n  le: (a: any, b: any) => a <= b,\n  // equal(=)\n  eq: (a: any, b: any) => a === b,\n  //  not equal(!=)\n  ne: (a: any, b: any) => a !== b,\n\n  in: (a: any, b: any[]) => b.indexOf(a) !== -1,\n  notin: (a: any, b: any[]) => b.indexOf(a) === -1,\n  // LIKE SQL statement(for strings compare)\n  like: (a: string, b: string) => {\n    return like(a, b);\n  },\n  // ILIKE SQL statement(for strings compare)\n  ilike: (a: string, b: string) => {\n    return like(a, b, true);\n  },\n};\n\nexport function isPropertyFilter(\n  filter: PropertyFilter | PropertiesFilter | string,\n): filter is PropertyFilter {\n  const pf = filter as PropertyFilter;\n  if (\n    pf.length === 3 &&\n    typeof pf[0] === 'string' &&\n    typeof pf[1] === 'string'\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/** @deprecated use {@link isPropertyFilter} instead */\nexport function checkIfPropertyFilter(\n  filter: PropertyFilter | PropertiesFilter | string,\n): filter is PropertyFilter {\n  return isPropertyFilter(filter);\n}\n\nexport function featureFilter(\n  feature: Feature,\n  filters: PropertiesFilter,\n): boolean {\n  const properties: Properties = { ...feature.properties };\n  if (properties) {\n    // workaround to filter by feature id\n    properties.$id = feature.id;\n    return propertiesFilter(properties, filters);\n  }\n  return false;\n}\n\nexport function propertiesFilter<T extends Properties = Properties>(\n  properties: T,\n  filters: PropertiesFilter<T>,\n): boolean {\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n  const filterFunction = (p: PropertyFilter | PropertiesFilter) => {\n    if (isPropertyFilter(p)) {\n      const [field, operation, value] = p;\n      const operationExec = operationsAliases[operation];\n      if (operationExec) {\n        if (operation === 'like' || operation === 'ilike') {\n          if (typeof field === 'string') {\n            let prop = '';\n            const value_ = field.replace(/^%?(\\w+)%?$/, (match, cleanField) => {\n              prop = properties[cleanField];\n              return field.replace(cleanField, value);\n            });\n            return operationExec(prop, value_);\n          }\n        }\n        return operationExec(properties[field], value);\n      }\n      return false;\n    } else {\n      return propertiesFilter(properties, p);\n    }\n  };\n  const filters_ = filters.filter((x) => Array.isArray(x)) as (\n    | PropertyFilter\n    | PropertiesFilter\n  )[];\n  return logic === 'any'\n    ? filters_.some(filterFunction)\n    : filters_.every(filterFunction);\n}\n","export interface ApplyMixinOptions {\n  replace?: boolean;\n}\n\ntype Ctor = any;\n\nexport function applyMixins(\n  derivedCtor: Ctor,\n  baseCtors: Ctor[],\n  opt: ApplyMixinOptions = {},\n): void {\n  const derivedProperties = allProperties(derivedCtor.prototype);\n  const replace = opt.replace !== undefined ? opt.replace : true;\n  baseCtors.forEach((baseCtor) => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {\n      const isSomeProp = derivedProperties.indexOf(name) !== -1;\n      if ((!replace && !isSomeProp) || replace) {\n        const descriptor = Object.getOwnPropertyDescriptor(\n          baseCtor.prototype,\n          name,\n        );\n        if (descriptor) {\n          Object.defineProperty(derivedCtor.prototype, name, descriptor);\n        }\n      }\n    });\n  });\n}\n\nexport function allProperties(obj: Record<string, unknown>): string[] {\n  return _allProperties(obj);\n}\n\nfunction _allProperties(\n  obj: Record<string, unknown>,\n  _props: string[] = [],\n): string[] {\n  for (; obj !== null; obj = Object.getPrototypeOf(obj)) {\n    const op = Object.getOwnPropertyNames(obj);\n    for (let i = 0; i < op.length; i++) {\n      if (_props.indexOf(op[i]) == -1) {\n        _props.push(op[i]);\n      }\n    }\n  }\n  return _props;\n}\n\nexport function mixinProperties(\n  derivedCtor: Ctor,\n  baseCtor: Ctor,\n  properties: string[],\n): void {\n  properties.forEach((name) => {\n    const descriptor = Object.getOwnPropertyDescriptor(\n      baseCtor.prototype,\n      name,\n    );\n    if (descriptor) {\n      Object.defineProperty(derivedCtor.prototype, name, descriptor);\n    }\n  });\n}\n","import type { LayerAdaptersOptions, AdapterOptions } from '@nextgis/webmap';\n\nimport type { QmsBasemap, QmsLayerType } from '../interfaces';\n\nexport const alias: { [key in QmsLayerType]: keyof LayerAdaptersOptions } = {\n  tms: 'TILE',\n};\n\nexport function updateQmsOptions(\n  qms: QmsBasemap,\n): AdapterOptions & { url: string } {\n  const protocol = (location.protocol === 'https:' ? 'https' : 'http') + '://';\n  let serviceUrl = qms.url.replace(/^(https?|ftp):\\/\\//, protocol);\n  if (!qms.y_origin_top) {\n    serviceUrl = serviceUrl.replace('{y}', '{-y}');\n  }\n  return {\n    url: serviceUrl,\n    name: qms.name,\n    attribution: qms.copyright_text,\n    maxZoom: qms.z_max,\n    minZoom: qms.z_min,\n  };\n}\n","import { fixUrlStr } from '@nextgis/utils';\n\nexport function loadJson<T = any>(url: string): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    const xmlHttp = new XMLHttpRequest();\n    xmlHttp.onreadystatechange = () => {\n      if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {\n        if (xmlHttp.responseText) {\n          try {\n            resolve(JSON.parse(xmlHttp.responseText));\n          } catch (er) {\n            reject(er);\n          }\n        }\n      }\n    };\n    xmlHttp.open('GET', fixUrlStr(url), true); // true for asynchronous\n    xmlHttp.send();\n  });\n}\n","export function getSubdomainsOriginUrl(originUrl: string): [string, string[]] {\n  const submodules: string[] = [];\n  originUrl = originUrl.replace(/{switch:(.*?)}/, (m, group) => {\n    if (typeof group === 'string') {\n      group.split(',').forEach((s) => submodules.push(s));\n    }\n    return '{s}';\n  });\n  return [originUrl, submodules];\n}\n","import { mixinProperties } from '@nextgis/utils';\nimport { alias, updateQmsOptions } from './updateQmsOptions';\nimport { loadJson } from './loadJson';\nimport { getSubdomainsOriginUrl } from './getSubmodulesFromOriginUrl';\n\nimport type { Type } from '@nextgis/utils';\nimport type { WebMap, MainLayerAdapter } from '@nextgis/webmap';\nimport type {\n  QmsAdapterOptions,\n  QmsBasemap,\n  QmsAdapter as QA,\n} from '../interfaces';\n\nconst URL = 'https://qms.nextgis.com';\n\nexport function createQmsAdapter(\n  webMap: WebMap,\n  url = URL,\n  createOpt: Partial<QmsAdapterOptions> = {},\n): Type<MainLayerAdapter> {\n  if (!url) {\n    url = URL;\n  }\n  class QmsAdapter<M = any> implements MainLayerAdapter<M>, QA {\n    qms?: QmsBasemap;\n\n    options: QmsAdapterOptions;\n    map: M;\n\n    constructor(map: M, options: QmsAdapterOptions) {\n      this.map = map;\n      const opt = { ...createOpt, ...options };\n      this.options = opt;\n      this.options.baselayer = true;\n      if (opt.qms) {\n        this.qms = opt.qms;\n      }\n    }\n\n    async addLayer(options: QmsAdapterOptions): Promise<any> {\n      // qmsId for request, id for store\n      if (!this.qms && options.qmsId) {\n        try {\n          this.qms = await loadJson<QmsBasemap>(\n            url + '/api/v1/geoservices/' + options.qmsId,\n          );\n        } catch (er) {\n          console.error(er);\n        }\n      }\n      const qms = this.qms;\n      if (qms) {\n        const type = alias[qms.type || 'tms'];\n        const WebMapAdapter = webMap.mapAdapter.layerAdapters[type];\n        if (WebMapAdapter) {\n          mixinProperties(QmsAdapter, WebMapAdapter, [\n            'showLayer',\n            'hideLayer',\n          ]);\n          if (type === 'TILE') {\n            options = {\n              order: 0,\n              maxZoom: webMap.options.maxZoom,\n              minZoom: webMap.options.minZoom,\n              ...this.options,\n              ...updateQmsOptions(qms),\n            };\n            if (qms.origin_url) {\n              const [url, subdomains] = getSubdomainsOriginUrl(qms.origin_url);\n              if (subdomains.length) {\n                options.subdomains = subdomains;\n                options.url = url;\n              }\n            }\n            this.options = options;\n            const adapter = new WebMapAdapter(this.map, options);\n            return adapter.addLayer(options);\n          }\n        }\n      }\n    }\n  }\n  return QmsAdapter;\n}\n","import { createQmsAdapter } from './utils/createQmsAdapter';\n\nimport type { Type } from '@nextgis/utils';\nimport type {\n  WebMap,\n  StarterKit,\n  MainLayerAdapter,\n  LayerAdapterCreators,\n} from '@nextgis/webmap';\nimport type { QmsOptions } from './interfaces';\n\nexport class QmsKit implements StarterKit {\n  static utils = {\n    createQmsAdapter,\n  };\n\n  options: QmsOptions = {\n    url: 'https://qms.nextgis.com',\n  };\n\n  url: string;\n\n  constructor(options?: QmsOptions) {\n    this.options = { ...this.options, ...options };\n    this.url = this.options.url;\n  }\n\n  getLayerAdapters(): Promise<LayerAdapterCreators[]> {\n    return Promise.resolve([\n      {\n        name: 'QMS',\n        createAdapter: (webmap: WebMap) =>\n          Promise.resolve(this._createAdapter(webmap)),\n      },\n    ]);\n  }\n\n  private _createAdapter(webMap: WebMap): Type<MainLayerAdapter> {\n    return createQmsAdapter(webMap, this.url);\n  }\n}\n","/**\n * @module url-runtime-params\n */\n\nimport { UrlRuntimeParams } from './UrlRuntimeParams';\n\nexport * from './interfaces';\n\nexport default UrlRuntimeParams;\n","import type { RuntimeParams } from '@nextgis/webmap';\nimport type { Params, StateData } from './interfaces';\n\nexport class UrlRuntimeParams implements RuntimeParams {\n  private _params: Params = {};\n\n  get(name: string): any {\n    return this.params()[name];\n  }\n\n  params(): Record<string, string> {\n    // if (this._params) {\n    //   return this._params;\n    // }\n    const href = window.location.href.replace(/#$/, '');\n    const params: Params = {};\n    href.replace(/[?&]+(\\w+)([^&]*)/gi, function (m, key) {\n      params[key] = true;\n      return ''; // does not matter\n    });\n    href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function (m, key, value) {\n      params[key] = decodeURIComponent(value);\n      return ''; // does not matter\n    });\n    this._params = params;\n    return params;\n  }\n\n  set(name: string, value: string): StateData {\n    if (value) {\n      let search: string;\n      const urlComponent = encodeURIComponent(value);\n      const existUrlParam = this.get(name);\n      if (existUrlParam) {\n        search = location.search.replace(\n          new RegExp('([?|&]' + name + '=)' + '(.+?)(&|$)'),\n          '$1' + urlComponent + '$3',\n        );\n      } else if (location.search.length) {\n        search = location.search + '&' + name + '=' + urlComponent;\n      } else {\n        search = '?' + name + '=' + urlComponent;\n      }\n      const params: Params = {};\n      params[name] = value;\n      this._params[name] = value;\n      const data: StateData = { state: { url: search, params }, url: search };\n      this._pushState(data);\n      return data;\n    } else {\n      return this.remove(name);\n    }\n  }\n\n  remove(name: string): StateData {\n    const sourceUrl = location.search;\n    let rtn = sourceUrl.split('?')[0];\n    let param: string;\n    let paramsArr: string[];\n    const queryString =\n      sourceUrl.indexOf('?') !== -1 ? sourceUrl.split('?')[1] : '';\n    if (queryString !== '') {\n      paramsArr = queryString.split('&');\n      for (let i = paramsArr.length - 1; i >= 0; i -= 1) {\n        param = paramsArr[i].split('=')[0];\n        if (param === name) {\n          paramsArr.splice(i, 1);\n        }\n      }\n      rtn = rtn + '?' + paramsArr.join('&');\n    }\n\n    delete this._params[name];\n\n    const data: StateData = { state: { url: rtn, type: 'remove' }, url: rtn };\n    this._pushState(data);\n\n    return data;\n  }\n\n  private _pushState(data: StateData): void {\n    if (history) {\n      history.replaceState(null, document.title, data.url);\n    }\n  }\n}\n","export function arrayUnique<T = any>(arr: T[]): T[] {\n  return arr.filter((elem, pos, arr) => {\n    return arr.indexOf(elem) == pos;\n  });\n}\n","// based on https://github.com/bvaughn/debounce-decorator\n\nexport function debounce<T extends (...args: any[]) => void>(\n  cb: T,\n  wait = 10,\n): T & { clear: () => void } {\n  let timeoutId: any;\n\n  function wrapper(this: any, ...args: any[]) {\n    wrapper.clear();\n\n    timeoutId = setTimeout(() => {\n      timeoutId = null;\n      cb.apply(this, args);\n    }, wait);\n  }\n\n  wrapper.clear = function () {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n  };\n\n  return wrapper as T & { clear: () => void };\n}\n\nexport function DebounceDecorator(wait = 10) {\n  return function (\n    target: unknown,\n    key: string,\n    descriptor: PropertyDescriptor,\n  ): PropertyDescriptor {\n    return {\n      configurable: true,\n      enumerable: descriptor.enumerable,\n      get: function getter() {\n        // Attach this function to the instance (not the class)\n        Object.defineProperty(this, key, {\n          configurable: true,\n          enumerable: descriptor.enumerable,\n          value: debounce(descriptor.value, wait),\n        });\n        // @ts-ignore\n        return this[key];\n      },\n    };\n  };\n}\n","/**\n * from https://github.com/CesiumGS/cesium/blob/master/Source/Core/defined.js\n *\n * @param val - The object.\n * @returns Returns true if the object is defined, returns false otherwise.\n *\n * @example\n * ```javascript\n * if (defined(positions)) {\n *   doSomething();\n * } else {\n *   doSomethingElse();\n * }\n * ```\n */\nexport function defined<T>(val: T): val is Exclude<T, null | undefined> {\n  return val !== undefined && val !== null;\n}\n\n/**\n * from https://github.com/CesiumGS/cesium/blob/master/Source/Core/defined.js\n *\n * @param val - The object.\n * @returns Returns true if the object is defined and not empty string, returns false otherwise.\n *\n * @example\n * ```javascript\n * full('foo') // true\n * full('') // false\n * full(undefined) // false\n * full(0) // true\n * ```\n */\nexport function full<T>(val: T): val is Exclude<T, null | undefined> {\n  return typeof val === 'string' ? !!val : defined(val);\n}\n","import type { EventEmitter } from 'events';\n\nexport class Events<E = any> {\n  private readonly _eventsStatus: { [key in keyof E]?: boolean } = {};\n\n  constructor(private emitter: EventEmitter) {}\n\n  setEventStatus(event: keyof E, status: boolean): void {\n    this._eventsStatus[event] = status;\n  }\n\n  onLoad(event: keyof E | (keyof E)[]): Promise<this> {\n    const events: (keyof E)[] = Array.isArray(event) ? event : [event];\n    const promises = events.map(\n      (x) =>\n        new Promise((res) => {\n          if (this.getEventStatus(x)) {\n            res(this);\n          } else {\n            const e = x as string | symbol;\n            this.emitter.once(e, () => {\n              this.setEventStatus(x, true);\n              res(this);\n            });\n          }\n        }),\n    );\n    return Promise.all(promises).then(() => this);\n  }\n\n  getEventStatus(event: keyof E): boolean {\n    // ugly hack to disable type checking error\n    const _eventName = event as keyof E;\n    const status = this._eventsStatus[_eventName];\n    return status !== undefined ? !!status : false;\n  }\n}\n","function isEqual(a: unknown, b: unknown, o: unknown, p: unknown): boolean {\n  if (a instanceof Array) {\n    if (!(b instanceof Array)) return false;\n    //if (compareObjects(oVal, pVal === false) return false\n    //would work, too, and perhaps is a better fit, still, this is easy, too\n    return b.sort().join('') === a.sort().join('');\n  } else if (a instanceof Date) {\n    if (!(b instanceof Date)) return false;\n    return '' + a === '' + b;\n  } else if (a instanceof Function) {\n    if (!(b instanceof Function)) return false;\n    //ignore functions, or check them regardless?\n  } else if (a instanceof Object) {\n    if (!(b instanceof Object)) return false;\n    if (a === o) {\n      return b === p;\n    } else {\n      return objectDeepEqual(a, b);\n    }\n  }\n  return a === b;\n}\n\n// based on https://stackoverflow.com/a/13143059\nexport function objectDeepEqual<\n  T extends Record<string, any> = Record<string, any>,\n>(o: T, p: T): boolean {\n  const keysO = Object.keys(o).sort();\n  const keysP = Object.keys(p).sort();\n  if (keysO.length !== keysP.length) return false;\n  if (keysO.join('') !== keysP.join('')) return false;\n  for (let i = 0; i < keysO.length; i++) {\n    const oVal = o[keysO[i]];\n    const pVal = p[keysP[i]];\n    if (!isEqual(oVal, pVal, o, p)) {\n      return false;\n    }\n  }\n  return true;\n}\n","export function objectRemoveEmpty<T extends Record<any, any>>(obj: T): T {\n  const newObj: Record<any, any> = {} as T;\n  Object.keys(obj).forEach((key) => {\n    if (!(obj[key] instanceof Array) && obj[key] === Object(obj[key])) {\n      newObj[key] = objectRemoveEmpty(obj[key]);\n    } else if (obj[key] !== undefined) {\n      newObj[key] = obj[key];\n    }\n  });\n  return newObj;\n}\n","export function numberWithSpaces(x: number): string {\n  const parts = x.toString().split('.');\n  parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, ' ');\n  return parts.join('.');\n}\n","export function fixUrlStr(url: string): string {\n  // remove double slash\n  return url.replace(/([^:]\\/)\\/+/g, '$1');\n}\n","import type {\n  GeoJsonObject,\n  GeoJsonGeometryTypes,\n  FeatureCollection,\n  GeometryCollection,\n  Feature,\n} from 'geojson';\n\n/**\n * @internal\n */\nexport function findMostFrequentGeomType(\n  arr: GeoJsonGeometryTypes[],\n): GeoJsonGeometryTypes {\n  const counts: { [x: string]: number } = {};\n  for (let fry = 0; fry < arr.length; fry++) {\n    counts[arr[fry]] = 1 + (counts[arr[fry]] || 0);\n  }\n  let maxName;\n  for (const c in counts) {\n    const count = maxName !== undefined ? counts[maxName] : 0;\n    if (counts[c] > (count || 0)) {\n      maxName = c;\n    }\n  }\n  return maxName as GeoJsonGeometryTypes;\n}\n\n/**\n * @internal\n */\nexport function detectGeometryType(\n  geojson: GeoJsonObject,\n): GeoJsonGeometryTypes {\n  let geometry: GeoJsonGeometryTypes;\n  if (geojson.type === 'FeatureCollection') {\n    const featuresTypes = (geojson as FeatureCollection).features.map(\n      (f) => f.geometry.type,\n    );\n    geometry = findMostFrequentGeomType(featuresTypes);\n  } else if (geojson.type === 'GeometryCollection') {\n    const geometryTypes = (geojson as GeometryCollection).geometries.map(\n      (g) => g.type,\n    );\n    geometry = findMostFrequentGeomType(geometryTypes);\n  } else if (geojson.type === 'Feature') {\n    geometry = (geojson as Feature).geometry.type;\n  } else {\n    geometry = geojson.type;\n  }\n  return geometry;\n}\n","import { isPaint } from '@nextgis/paint';\nimport { detectGeometryType } from './geometryTypes';\n\nimport type {\n  GeoJsonAdapterOptions,\n  VectorAdapterLayerType,\n} from '../interfaces/LayerAdapter';\n\n/**\n * @internal\n */\nexport const paintTypeAlias: Record<VectorAdapterLayerType, any> = {\n  polygon: 'path',\n  line: 'path',\n  point: 'circle',\n};\n\nexport const typeAlias: { [x: string]: VectorAdapterLayerType } = {\n  Point: 'point',\n  LineString: 'line',\n  MultiPoint: 'point',\n  Polygon: 'polygon',\n  MultiLineString: 'line',\n  MultiPolygon: 'polygon',\n};\n\n/**\n * @internal\n */\nexport function updateGeoJsonAdapterOptions<\n  O extends GeoJsonAdapterOptions = GeoJsonAdapterOptions,\n>(opt: O): O {\n  if (opt.data) {\n    const geomType = typeAlias[detectGeometryType(opt.data)];\n    const p = opt.paint;\n    if (p && isPaint(p)) {\n      // define parameter if not specified\n      p.type = p.type\n        ? p.type\n        : geomType === 'polygon' || geomType === 'line'\n        ? 'path'\n        : 'html' in p || 'className' in p\n        ? 'icon'\n        : paintTypeAlias[geomType];\n    }\n    opt.type = opt.type || geomType;\n  }\n  return opt;\n}\n","export function deepmerge<T>(\n  x: Partial<T>,\n  y: Partial<T>,\n  mergeArray?: boolean,\n): T;\nexport function deepmerge<T1, T2>(\n  target: Partial<T1>,\n  src: Partial<T2>,\n  mergeArray = false,\n): T1 & T2 {\n  let target_ = target as any;\n  const src_ = src as any;\n  const array = Array.isArray(src_);\n  let dst: any = (array && []) || {};\n\n  if (array && Array.isArray(src_)) {\n    if (mergeArray) {\n      target_ = target_ || [];\n      dst = dst.concat(target_);\n      src_.forEach((e: any, i: number) => {\n        if (typeof dst[i] === 'undefined') {\n          dst[i] = e;\n        } else if (typeof e === 'object') {\n          dst[i] = deepmerge(target_[i], e, mergeArray);\n        } else {\n          if (target_.indexOf(e) === -1) {\n            dst.push(e);\n          }\n        }\n      });\n    } else {\n      // Replace array. Do not merge by default\n      dst = src_;\n    }\n  } else {\n    if (target_ && typeof target_ === 'object') {\n      Object.keys(target_).forEach(function (key) {\n        dst[key] = target_[key];\n      });\n    }\n    Object.keys(src_).forEach(function (key) {\n      if (typeof src_[key] !== 'object' || !src_[key]) {\n        dst[key] = src_[key];\n      } else {\n        if (typeof target_[key] === 'object' && typeof src_[key] === 'object') {\n          dst[key] = deepmerge(target_[key], src_[key], mergeArray);\n        } else {\n          dst[key] = src_[key];\n        }\n      }\n    });\n  }\n  return dst;\n}\n","import type { Feature, Polygon } from 'geojson';\nimport type { LngLatBoundsArray } from './interfaces';\n\nexport function getBoundsPolygon(b: LngLatBoundsArray): Polygon {\n  const polygon: Polygon = {\n    type: 'Polygon',\n    coordinates: [getBoundsCoordinates(b)],\n  };\n  return polygon;\n}\n\nexport function getBoundsCoordinates(b: LngLatBoundsArray): number[][] {\n  const westNorth = [b[0], b[1]];\n  const eastNorth = [b[2], b[1]];\n  const eastSouth = [b[2], b[3]];\n  const westSouth = [b[0], b[3]];\n\n  return [westNorth, eastNorth, eastSouth, westSouth, westNorth];\n}\n\nexport function getBoundsFeature(b: LngLatBoundsArray): Feature<Polygon> {\n  const feature: Feature<Polygon> = {\n    type: 'Feature',\n    properties: {},\n    geometry: getBoundsPolygon(b),\n  };\n  return feature;\n}\n","export class KeyCodes {\n  'backspace' = 8;\n  'tab' = 9;\n  'enter' = 13;\n  'shift' = 16;\n  'ctrl' = 17;\n  'alt' = 18;\n  'pause/break' = 19;\n  'caps_lock' = 20;\n  'escape' = 27;\n  'page_up' = 33;\n  'page_down' = 34;\n  'end' = 35;\n  'home' = 36;\n  'left_arrow' = 37;\n  'up_arrow' = 38;\n  'right_arrow' = 39;\n  'down_arrow' = 40;\n  'insert' = 45;\n  'delete' = 46;\n  'left_window_key' = 91;\n  'right_window_key' = 92;\n  'select_key' = 93;\n  'numpad_0' = 96;\n  'numpad_1' = 97;\n  'numpad_2' = 98;\n  'numpad_3' = 99;\n  'numpad_4' = 100;\n  'numpad_5' = 101;\n  'numpad_6' = 102;\n  'numpad_7' = 103;\n  'numpad_8' = 104;\n  'numpad_9' = 105;\n  'multiply' = 106;\n  'add' = 107;\n  'subtract' = 109;\n  'decimal_point' = 110;\n  'divide' = 111;\n  'f1' = 112;\n  'f2' = 113;\n  'f3' = 114;\n  'f4' = 115;\n  'f5' = 116;\n  'f6' = 117;\n  'f7' = 118;\n  'f8' = 119;\n  'f9' = 120;\n  'f10' = 121;\n  'f11' = 122;\n  'f12' = 123;\n  'num_lock' = 144;\n  'scroll_lock' = 145;\n  'semi-colon' = 186;\n  'equal_sign' = 187;\n  ',' = 188; // \"comma\";\n  '-' = 189; // \"dash\";\n  '.' = 190; // \"period\";\n  '/' = 191; // \"forward slash\";\n  '`' = 192; // \"grave accent\";\n  '[' = 219; // \"open bracket\";\n  '\\\\' = 220; // \"back slash\";\n  ']' = 221; // \"close braket\";\n  \"'\" = 222; // \"single quote\"\n}\n","import type { WebMap } from '../../WebMap';\nimport type { MapStateItem } from '../../interfaces/MapState';\nimport type { WebMapEvents } from '../../interfaces/Events';\nimport type { MapOptions } from '../../interfaces/MapOptions';\n\nexport abstract class StateItem<V extends any | undefined = any | undefined>\n  implements MapStateItem<V | undefined>\n{\n  name!: keyof MapOptions;\n  event!: keyof WebMapEvents;\n  protected value?: V;\n\n  constructor(\n    protected webMap: WebMap,\n    opt?: { name?: keyof MapOptions; event?: keyof WebMapEvents; value?: V },\n  ) {\n    if (opt) {\n      if (opt.value) {\n        this.setValue(opt.value);\n      }\n      if (opt.name) {\n        this.name = opt.name;\n      }\n      if (opt.event) {\n        this.event = opt.event;\n      }\n    }\n  }\n\n  getValue(): V | undefined {\n    return this.value;\n  }\n\n  setValue(val: V): void {\n    this.value = val;\n  }\n\n  abstract toString(data: unknown): string;\n  abstract parse(str: string): V;\n}\n","import { StateItem } from './StateItem';\n\nimport type { LngLatArray } from '@nextgis/utils';\nimport type { WebMapEvents } from '../../interfaces/Events';\nimport type { MapOptions } from '../../interfaces/MapOptions';\n\nexport class CenterState extends StateItem<LngLatArray> {\n  name: keyof MapOptions = 'center';\n  event: keyof WebMapEvents = 'moveend';\n\n  getValue(): LngLatArray | undefined {\n    return this.webMap.getCenter();\n  }\n  setValue(val: LngLatArray): void {\n    this.webMap.setCenter(val);\n  }\n  toString(data: LngLatArray): string {\n    const d = data.map((x) => x.toFixed(5));\n    return d[0] + '_' + d[1];\n  }\n  parse(str: string): LngLatArray {\n    const lngLat = str.split('_').map(Number) as LngLatArray;\n    return lngLat;\n  }\n}\n","import { StateItem } from './StateItem';\nimport type { WebMapEvents } from '../../interfaces/Events';\nimport type { MapOptions } from '../../interfaces/MapOptions';\n\nexport class ZoomState extends StateItem<number> {\n  name: keyof MapOptions = 'zoom';\n  event: keyof WebMapEvents = 'zoomend';\n  getValue(): number | undefined {\n    const zoom = this.webMap.getZoom();\n    return zoom !== undefined ? Math.round(zoom) : undefined;\n  }\n  setValue(val: number): void {\n    this.webMap.setZoom(val);\n  }\n  toString(val: number): string {\n    return String(val);\n  }\n  parse(str: string): number {\n    return Number(str);\n  }\n}\n","import { EventEmitter } from 'events';\n\nimport { deepmerge, defined, getBoundsFeature } from '@nextgis/utils';\nimport { GetPaintFunction } from '@nextgis/paint';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { deprecatedMapClick } from '@nextgis/utils';\n\nimport { Keys } from './components/keys/Keys';\nimport { CenterState } from './components/mapStates/CenterState';\nimport { StateItem } from './components/mapStates/StateItem';\nimport { ZoomState } from './components/mapStates/ZoomState';\nimport { clearObject } from './utils/clearObject';\n\nimport type StrictEventEmitter from 'strict-event-emitter-types';\nimport type { Feature, Polygon } from 'geojson';\nimport type {\n  Type,\n  TileJson,\n  LngLatArray,\n  LngLatBoundsArray,\n} from '@nextgis/utils';\nimport type { Cursor } from './interfaces/BaseTypes';\nimport type {\n  LocationEvents,\n  MapClickEvent,\n  LocateOptions,\n  FitOptions,\n  MapAdapter,\n  Locate,\n} from './interfaces/MapAdapter';\nimport type { StarterKit } from './interfaces/StarterKit';\nimport type { LayerAdapter } from './interfaces/LayerAdapter';\nimport type { RuntimeParams } from './interfaces/RuntimeParams';\nimport type { MapOptions, ViewOptions } from './interfaces/MapOptions';\nimport type { WebMapEvents, MainMapEvents } from './interfaces/Events';\n\ntype EmitStatusEventData = any;\n\nlet ID = 0;\n\nconst OPTIONS: MapOptions = {\n  minZoom: 0,\n  maxZoom: 20,\n  paint: {\n    color: '#0000ff', // blue\n    opacity: 0.4,\n    strokeOpacity: 1,\n    stroke: true,\n    radius: 8,\n    weight: 1,\n  },\n  selectedPaint: {\n    color: '#00008b', // darkblue\n    opacity: 0.4,\n    strokeOpacity: 1,\n    stroke: true,\n    radius: 12,\n    weight: 1,\n  },\n  create: true,\n};\n\ninterface AddEventsListenersOptions {\n  include: (keyof MainMapEvents)[];\n}\n\nexport class WebMapMain<\n  M = any,\n  E extends WebMapEvents = WebMapEvents,\n  O extends MapOptions = MapOptions,\n> {\n  static keys: Keys = new Keys();\n\n  static getPaintFunctions: { [name: string]: GetPaintFunction };\n\n  options: O = OPTIONS as O;\n  // `WebMapEvents` must be `E` but its not work correct\n  readonly emitter: StrictEventEmitter<EventEmitter, WebMapEvents> =\n    new EventEmitter();\n  readonly keys = WebMapMain.keys;\n\n  readonly mapAdapter: MapAdapter<M>;\n  readonly runtimeParams: RuntimeParams[] = [];\n\n  getPaintFunctions = WebMapMain.getPaintFunctions;\n  mapState: Type<StateItem>[] = [CenterState, ZoomState];\n  id = ID++;\n\n  /**\n   * From runtime params\n   */\n  protected _initMapState: Record<string, any> = {};\n  protected readonly _starterKits: StarterKit[];\n  private _mapState: StateItem[] = [];\n  private _extent?: LngLatBoundsArray;\n  private readonly _eventsStatus: { [key in keyof E]?: boolean } = {};\n  private _coordFromMapClickPromise?: CancelablePromise<LngLatArray>;\n\n  private readonly _mapEvents: {\n    [key in keyof MainMapEvents]?: (...args: any[]) => void;\n  } = {};\n\n  constructor(mapOptions: O) {\n    this.mapAdapter = mapOptions.mapAdapter as MapAdapter<M>;\n    this._starterKits = mapOptions.starterKits || [];\n    if (mapOptions) {\n      this.options = deepmerge((OPTIONS as O) || {}, mapOptions) as O;\n    }\n    if (this.options.runtimeParams) {\n      this.runtimeParams = this.options.runtimeParams;\n    }\n    this._addEventsListeners();\n\n    if (this.options.tileJson) {\n      this._setTileJsonOptions(this.options.tileJson);\n    }\n    if (this.options.create) {\n      this.create();\n    }\n  }\n\n  getId(): number {\n    return this.id;\n  }\n\n  /**\n   * Manual way to create a map (If {@link MapOptions.create} is `false`).\n   * @example\n   * ```javascript\n   * const webMap = new WebMap(options);\n   * webMap.create().then(() => doSomething());\n   * ```\n   */\n  async create(): Promise<this> {\n    if (!this.getEventStatus('create')) {\n      await this._setInitMapState(this.mapState);\n      await this._setupMap();\n      this._emitStatusEvent('create', this);\n    }\n    return this;\n  }\n\n  setRuntimeParams(params: RuntimeParams): void {\n    this.runtimeParams.push(params);\n  }\n\n  /**\n   * Destroys WebMap, MapAdapter, clears all layers and turn off all event listeners\n   */\n  destroy(): void {\n    this._removeEventListeners();\n    clearObject(this._emitStatusEvent);\n    if (this.mapAdapter.destroy) {\n      this.mapAdapter.destroy();\n    }\n  }\n\n  getState(): Record<string, any> {\n    const state: Record<string, any> = {};\n    this._mapState.forEach((x) => {\n      state[x.name] = x.getValue();\n    });\n    return state;\n  }\n\n  getRuntimeParams(): Record<string, any> {\n    const state: Record<string, any> = {};\n    this._mapState.forEach((x) => {\n      for (const r of this.runtimeParams) {\n        const val = r.get(x.name);\n        if (val !== undefined) {\n          state[x.name] = x.parse(val);\n          break;\n        }\n      }\n    });\n    return state;\n  }\n\n  /**\n   * Returns the HTML element that contains the map.\n   * @returns The map's container\n   */\n  getContainer(): HTMLElement | undefined {\n    if (this.mapAdapter.getContainer) {\n      return this.mapAdapter.getContainer();\n    } else if (this.options.target) {\n      if (this.options.target instanceof HTMLElement) {\n        return this.options.target;\n      } else if (typeof this.options.target === 'string') {\n        const element = document.getElementById(this.options.target);\n        if (element) {\n          return element;\n        }\n      }\n    }\n  }\n\n  /**\n   * Set the cursor icon to be displayed when hover icon on the map container.\n   * @param cursor - Available cursor name from https://developer.mozilla.org/ru/docs/Web/CSS/cursor\n   */\n  setCursor(cursor: Cursor): void {\n    if (this.mapAdapter.setCursor) {\n      this.mapAdapter.setCursor(cursor);\n    }\n  }\n\n  getCursor(): Cursor | undefined {\n    if (this.mapAdapter.getCursor) {\n      return this.mapAdapter.getCursor() as Cursor;\n    }\n    const container = this.getContainer();\n    if (container) {\n      return container.style.cursor as Cursor;\n    }\n  }\n\n  /**\n   * Set the center of the current view.\n   * @param lngLat - Array of two numbers representing longitude and latitude of the center of the map view.\n   *\n   * @example\n   * ```javascript\n   * // Mount Everest 27° 59′ 17″ N, 86° 55′ 31″ E\n   * webMap.setCenter([86.925278, 27.988056]);\n   * ```\n   */\n  setCenter(lngLat: LngLatArray): this {\n    this.mapAdapter.setCenter(lngLat);\n    return this;\n  }\n\n  /**\n   * Returns the map's geographical centerpoint.\n   * @returns lngLat Array of two numbers representing longitude and latitude of the center of the map view.\n   *\n   * @example\n   * ```javascript\n   * // Mount Everest 27° 59′ 17″ N, 86° 55′ 31″ E\n   * webMap.getCenter(); // [86.925278, 27.988056]\n   * ```\n   */\n  getCenter(): LngLatArray | undefined {\n    return this.mapAdapter.getCenter();\n  }\n\n  getBounds(): LngLatBoundsArray | undefined {\n    if (this.mapAdapter.getBounds) {\n      return this.mapAdapter.getBounds();\n    }\n  }\n\n  getBoundsPolygon(): Feature<Polygon> | undefined {\n    const bounds = this.getBounds();\n    if (bounds) {\n      const feature = getBoundsFeature(bounds);\n      return feature;\n    }\n  }\n\n  /**\n   * Zoom to a specific zoom level.\n   * @param zoom - The zoom level to set (0-24).\n   */\n  setZoom(zoom: number): this {\n    this.mapAdapter.setZoom(zoom);\n    return this;\n  }\n\n  /**\n   * Returns the map's current zoom level.\n   * @returns The map's current zoom level (0-24).\n   */\n  getZoom(): number | undefined {\n    const zoom = this.mapAdapter.getZoom();\n    if (typeof zoom === 'number') {\n      return zoom;\n    }\n    // throw Error(\n    //   'Unable to get zoom level. Perhaps the map is not have been initialized yet',\n    // );\n  }\n\n  zoomIn(): void {\n    if (this.mapAdapter.zoomIn) {\n      this.mapAdapter.zoomIn();\n    } else {\n      const zoom = this.getZoom();\n      if (zoom !== undefined) {\n        const toZoom = zoom + 1;\n        this.setZoom(toZoom);\n      }\n    }\n  }\n\n  zoomOut(): void {\n    if (this.mapAdapter.zoomOut) {\n      this.mapAdapter.zoomOut();\n    } else {\n      const zoom = this.getZoom();\n      if (zoom !== undefined) {\n        const toZoom = zoom - 1;\n        this.setZoom(toZoom);\n      }\n    }\n  }\n\n  /**\n   * Sets the view of the map geographical center and zoom\n   * @param lngLat - Array of two numbers representing longitude and latitude of the center of the map view.\n   * @param zoom - The zoom level to set (0-24).\n   *\n   * @example\n   * ```javascript\n   * // Mount Everest 27° 59′ 17″ N, 86° 55′ 31″ E\n   * webMap.setView([86.925278, 27.988056], 12)\n   * ```\n   */\n  setView(lngLatOr: LngLatArray, zoom?: number): void;\n\n  setView(options: ViewOptions): void;\n\n  setView(lngLatOrOpt: LngLatArray | ViewOptions, zoom?: number): void {\n    if (Array.isArray(lngLatOrOpt)) {\n      const lngLat = lngLatOrOpt;\n      if (this.mapAdapter.setView && lngLat && defined(zoom)) {\n        this.mapAdapter.setView(lngLat, zoom);\n      } else {\n        if (lngLat) {\n          this.mapAdapter.setCenter(lngLat);\n        }\n        if (defined(zoom)) {\n          this.mapAdapter.setZoom(zoom);\n        }\n      }\n    } else {\n      const viewOpt = lngLatOrOpt;\n      if (this.mapAdapter.setView) {\n        this.mapAdapter.setView(viewOpt);\n      }\n    }\n  }\n\n  /**\n   * Sets a map view that contains the given geographical bounds.\n   * @param bounds - Array of coordinates, measured in degrees, in [west, south, east, north] order.\n   *\n   * @example\n   * ```javascript\n   * // Whole world\n   * webMap.fitBounds([0, -90, 180, 90]);\n   * ```\n   */\n  fitBounds(bounds: LngLatBoundsArray, options?: FitOptions): this {\n    if (bounds.every((x) => defined(x))) {\n      if (bounds[1] < -85.06) {\n        bounds[1] = -85.06;\n      }\n      if (bounds[3] > 85.06) {\n        bounds[3] = 85.06;\n      }\n      this.mapAdapter.fitBounds(bounds, options);\n    }\n    return this;\n  }\n\n  /**\n   * Checking the status of any asynchronous operation\n   * @param event - The name of the event whose status is checked\n   *\n   * @example\n   * ```javascript\n   * var webMap = new WebMap(options);\n   * webMap.getEventStatus('create'); // false\n   * webMap.emitter.on('create', function () {\n   *   webMap.getEventStatus('create'); // true\n   * })\n   * ```\n   */\n  getEventStatus(event: keyof E): boolean {\n    // ugly hack to disable type checking error\n    const _eventName = event as keyof WebMapEvents;\n    const status = this._eventsStatus[_eventName];\n    return status ?? false;\n  }\n\n  /**\n   * helper method to wait for events to load. By default, card creation is tracked\n   * @param event - The name of the event whose status is checked\n   *\n   * @example\n   * ```javascript\n   * var webMap = new WebMap(options);\n   * webMap.onLoad().then(function () {\n   *   webMap.getEventStatus('create'); // true\n   * })\n   *\n   * // use async/await syntax\n   * async function () {\n   *   await webMap.onLoad();\n   *   doSomething();\n   * }\n   *\n   * ```\n   */\n  onLoad(event: keyof WebMapEvents = 'create'): Promise<this> {\n    return new Promise((res) => {\n      if (this.getEventStatus(event)) {\n        res(this);\n      } else {\n        this.emitter.once(event, () => {\n          res(this);\n        });\n      }\n    });\n  }\n\n  onMapLoad(cb?: (mapAdapter: MapAdapter) => void): Promise<MapAdapter> {\n    return new Promise((res) => {\n      const _resolve = () => {\n        const mapAdapter = this.mapAdapter;\n        if (cb) {\n          cb(mapAdapter);\n        }\n        if (mapAdapter) {\n          res(mapAdapter);\n        }\n      };\n      const isLoaded = this.mapAdapter.isLoaded ?? true;\n      if (this.mapAdapter.map && isLoaded) {\n        _resolve();\n      } else {\n        this.mapAdapter.emitter.once('create', () => {\n          _resolve();\n        });\n      }\n    });\n  }\n\n  getLayerAdapters(): { [name: string]: Type<LayerAdapter> } {\n    return this.mapAdapter.layerAdapters;\n  }\n\n  getLayerAdapter(name: string): Type<LayerAdapter> {\n    const adapter = this.mapAdapter.layerAdapters[name];\n    return adapter;\n  }\n\n  locate(opt: LocateOptions, events?: LocationEvents): Locate {\n    if (this.mapAdapter && this.mapAdapter.locate) {\n      return this.mapAdapter.locate(opt, events);\n    }\n    const stop = () => ({});\n    return { stop };\n  }\n\n  stopGetCoordFromMapClick(): void {\n    if (this._coordFromMapClickPromise) {\n      this._coordFromMapClickPromise.cancel();\n    }\n  }\n\n  getCoordFromMapClick(): CancelablePromise<LngLatArray> {\n    if (!this._coordFromMapClickPromise) {\n      this._coordFromMapClickPromise = new CancelablePromise(\n        (resolve, reject, onCancel) => {\n          const cursor: Cursor = this.getCursor() || 'grab';\n          this._removeEventListeners({ include: ['click'] });\n          this.setCursor('crosshair');\n          const onCancel_ = (): void => {\n            this.setCursor(cursor);\n            this._addEventsListeners({ include: ['click'] });\n            this.mapAdapter.emitter.off('click', onMapClick);\n            this._coordFromMapClickPromise = undefined;\n          };\n          const onMapClick = (e: MapClickEvent) => {\n            onCancel_();\n            deprecatedMapClick(e);\n            resolve(e.lngLat);\n          };\n          this.mapAdapter.emitter.once('click', onMapClick);\n          onCancel(onCancel_);\n        },\n      );\n    } else {\n      return this.getCoordFromMapClick();\n    }\n    return this._coordFromMapClickPromise;\n  }\n\n  protected _emitStatusEvent(\n    eventName: keyof E,\n    data?: EmitStatusEventData,\n  ): void {\n    // ugly hack to disable type checking error\n    const _eventName = eventName as keyof WebMapEvents;\n    this._eventsStatus[_eventName] = true;\n    this.emitter.emit(_eventName, data);\n  }\n\n  protected async _addLayerProviders(): Promise<void> {\n    //\n  }\n\n  protected async _onLoadSync(): Promise<void> {\n    //\n  }\n\n  private async _setupMap(): Promise<this> {\n    if (!this.mapAdapter) {\n      throw new Error('WebMap `mapAdapter` option is not set');\n    }\n    await this.mapAdapter.create(this.options);\n    this._zoomToInitialExtent();\n\n    await this._addLayerProviders();\n    await this._onLoadSync();\n\n    this._emitStatusEvent('build-map', this.mapAdapter);\n    return this;\n  }\n\n  private _setTileJsonOptions(tileJson: TileJson): void {\n    if (tileJson.center) {\n      this.options.center = tileJson.center;\n    }\n    if (tileJson.bounds) {\n      this.options.bounds = tileJson.bounds;\n    }\n    if (defined(tileJson.maxzoom)) {\n      this.options.maxZoom = tileJson.maxzoom;\n      this.options.zoom = tileJson.maxzoom;\n    }\n    if (defined(tileJson.minzoom)) {\n      this.options.minZoom = tileJson.minzoom;\n      this.options.zoom = tileJson.minzoom;\n    }\n    if (defined(tileJson.maxzoom) && defined(tileJson.minzoom)) {\n      this.options.zoom = (tileJson.maxzoom + tileJson.minzoom) / 2;\n    }\n  }\n\n  private _zoomToInitialExtent(): void {\n    const { center, zoom, bounds } = this.options;\n    if (this._extent) {\n      this.fitBounds(this._extent);\n    } else if (center && zoom) {\n      this.setView(center, zoom);\n    } else if (bounds) {\n      this.fitBounds(bounds);\n    }\n  }\n\n  private _setInitMapState(states: Type<StateItem>[]): void {\n    for (const X of states) {\n      const state = new X(this);\n      this._mapState.push(state);\n      for (const r of this.runtimeParams) {\n        const str = r.get(state.name);\n        if (str !== undefined) {\n          const val = state.parse(str);\n          // state.setValue(val);\n          this._initMapState[state.name] = val;\n          Object.defineProperty(this.options, state.name, {\n            value: val,\n            configurable: true,\n            enumerable: true,\n          });\n          break;\n        }\n      }\n    }\n  }\n\n  private _addEventsListeners(opt?: AddEventsListenersOptions): void {\n    let events: (keyof MainMapEvents)[] = [\n      'preclick',\n      'click',\n      'zoomstart',\n      'zoom',\n      'zoomend',\n      'movestart',\n      'move',\n      'moveend',\n      'mousemove',\n      'mouseout',\n      'mouseover',\n    ];\n\n    if (opt && opt.include) {\n      events = events.filter((x) => opt.include.includes(x));\n    }\n    events.forEach((x) => {\n      this._mapEvents[x] = (data): void => {\n        if (this.runtimeParams.length) {\n          const mapStatusEvent = this._mapState.find((y) => y.event === x);\n          if (mapStatusEvent) {\n            const value = mapStatusEvent.toString(mapStatusEvent.getValue());\n            this.runtimeParams.forEach((r) => {\n              r.set(mapStatusEvent.name, value);\n            });\n          }\n        }\n        if (this._eventsStatus) {\n          this.emitter.emit(x, data);\n        }\n      };\n      const mapEvent = this._mapEvents[x];\n      if (mapEvent) {\n        this.mapAdapter.emitter.on(x, mapEvent);\n      }\n    });\n  }\n\n  private _removeEventListeners(opt?: AddEventsListenersOptions): void {\n    let events = Object.entries(this._mapEvents) as [\n      keyof MainMapEvents,\n      ((...args: any[]) => void) | undefined,\n    ][];\n    if (opt && opt.include) {\n      events = events.filter((x) => opt.include.includes(x[0]));\n    }\n    events.forEach(([x, event]) => {\n      if (event) {\n        this.mapAdapter.emitter.removeListener(x as keyof MainMapEvents, event);\n      }\n    });\n  }\n}\n","/**\n * @internal\n */\nexport function clearObject(obj: Record<any, any>): void {\n  for (const member in obj) {\n    delete obj[member];\n  }\n}\n","import { debugLog } from '../debug/debugLog';\n\nimport type { LatLng } from '../geom/interfaces';\nimport type { LngLatArray } from '../geom/interfaces';\n\ninterface DeprecatedMapClickEvent {\n  lngLat: LngLatArray;\n  latLng?: LatLng;\n}\n\n/**\n * @internal\n */\nexport function deprecatedMapClick<\n  T extends DeprecatedMapClickEvent = DeprecatedMapClickEvent,\n>(ev: T): T {\n  if (!ev.lngLat && ev.latLng) {\n    debugLog('deprecated use of latLng in MapClickEvent, use lngLat instead');\n    const lat = ev.latLng.lat;\n    const lng = ev.latLng.lng;\n    ev.lngLat = [lng, lat];\n  }\n  return ev;\n}\n","import { KeyCodes } from './KeysCodes';\n\n/**\n * @param {string} key - key symbol\n * @param {string} func - action on key press\n * @param {number} [keyCode] - key code for special button like tab\n *\n * @export\n * @interface KeyControl\n */\nexport interface KeyControl {\n  key?: string;\n  keyCode?: number;\n  func: () => void;\n}\n\nexport class Keys {\n  keyCodeAlias = new KeyCodes();\n\n  keys: { [keyCode: number]: boolean } = {};\n\n  private _windowOnFocus: () => void;\n  private _keysPressed: (e: KeyboardEvent) => void;\n  private _keysReleased: (e: KeyboardEvent) => void;\n\n  constructor() {\n    this._windowOnFocus = this.windowOnFocus.bind(this);\n    this._keysPressed = this.keysPressed.bind(this);\n    this._keysReleased = this.keysReleased.bind(this);\n    this.addKeyboardEventsListener();\n  }\n\n  pressed(keyName: keyof KeyCodes): boolean {\n    const code = this.keyCodeAlias[keyName];\n    return !!code && this.keys[code];\n  }\n\n  addKeyboardEventsListener(): void {\n    if (typeof window !== 'undefined') {\n      window.addEventListener('focus', this._windowOnFocus, false);\n      window.addEventListener('keydown', this._keysPressed, false);\n      window.addEventListener('keyup', this._keysReleased, false);\n    }\n  }\n\n  removeKeyboardEventsListener(): void {\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('focus', this._windowOnFocus, false);\n      window.removeEventListener('keydown', this._keysPressed, false);\n      window.removeEventListener('keyup', this._keysReleased, false);\n    }\n  }\n\n  private keysPressed(e: KeyboardEvent) {\n    e.stopPropagation();\n    if (!this.keys[e.keyCode]) {\n      this.keys[e.keyCode] = true;\n    }\n  }\n\n  private keysReleased(e: KeyboardEvent) {\n    e.stopPropagation();\n    this.keys[e.keyCode] = false;\n  }\n\n  private windowOnFocus() {\n    this.keys = {};\n  }\n}\n","import { defined } from '@nextgis/utils';\nimport { Paint, preparePaint } from '@nextgis/paint';\nimport { propertiesFilter } from '@nextgis/properties-filter';\n\nimport { updateGeoJsonAdapterOptions } from './utils/updateGeoJsonAdapterOptions';\nimport { WebMapMain } from './WebMapMain';\n\nimport type { Feature, GeoJsonObject, Geometry } from 'geojson';\nimport type { FeatureProperties, TileJson, Type } from '@nextgis/utils';\nimport type { PropertiesFilter } from '@nextgis/properties-filter';\n\nimport type {\n  LayerAdapter,\n  LayerAdapters,\n  FilterOptions,\n  AdapterOptions,\n  LayerDefinition,\n  DataLayerFilter,\n  MainLayerAdapter,\n  AdapterConstructor,\n  VectorLayerAdapter,\n  TileAdapterOptions,\n  FeatureLayerAdapter,\n  ImageAdapterOptions,\n  OnLayerMouseOptions,\n  LayerAdaptersOptions,\n  OnLayerSelectOptions,\n  GeoJsonAdapterOptions,\n  LayerAdapterDefinition,\n} from './interfaces/LayerAdapter';\nimport type { LayerDef } from './interfaces/BaseTypes';\nimport type {\n  GetAttributionsOptions,\n  ToggleLayerOptions,\n  MapOptions,\n} from './interfaces/MapOptions';\nimport type { WebMapEvents } from './interfaces/Events';\nimport type { FitOptions } from './interfaces/MapAdapter';\n\ntype AddedLayers<M = any, L = any> = { [id: string]: LayerAdapter<M, L> };\n\nexport class WebMapLayers<\n  M = any,\n  L = any,\n  E extends WebMapEvents = WebMapEvents,\n  O extends MapOptions = MapOptions,\n> extends WebMapMain<M, E, O> {\n  private _layersIdCounter = 1;\n  private _layersOrderCounter = 1;\n  private readonly _baselayers: string[] = [];\n  private readonly _layers: AddedLayers<M, L> = {};\n  private readonly _selectedLayers: string[] = [];\n\n  constructor(mapOptions: O) {\n    super(mapOptions);\n    const tileJson = this.options.tileJson;\n    if (tileJson) {\n      this.emitter.once('build-map', () => this.addTileJsonLayer(tileJson));\n    }\n  }\n\n  /**\n   * Try to fit map view by given layer bounds.\n   * But not all layers have borders\n   */\n  async fitLayer(layerDef: LayerDef, options?: FitOptions): Promise<void> {\n    const layer = this.getLayer(layerDef);\n    // TODO: remove backward compatibility for `getExtent`\n    const getBounds = layer && (layer.getBounds || layer.getExtent);\n    if (getBounds) {\n      const extent = await getBounds.call(layer);\n      if (extent) {\n        this.fitBounds(extent, options);\n      }\n    }\n  }\n\n  /**\n   * Check if given layer is baselayer\n   */\n  isBaseLayer(layerDef: LayerDef): boolean | undefined {\n    const layer = this.getLayer(layerDef);\n    if (layer && layer.id) {\n      return this._baselayers.indexOf(layer.id) !== -1;\n    }\n    return undefined;\n  }\n\n  getBaseLayers(): LayerAdapter[] {\n    const baselayers: LayerAdapter[] = [];\n    this._baselayers.forEach((x) => {\n      const baselayer = this._layers[x];\n      if (baselayer) {\n        baselayers.push(baselayer);\n      }\n    });\n    return baselayers;\n  }\n\n  getBaseLayersIds(): string[] {\n    return this._baselayers;\n  }\n\n  /**\n   * Helper method to return added layer object by any definition type.\n   */\n  getLayer<LA extends LayerAdapter = LayerAdapter>(\n    layerDef: LayerDef,\n  ): LA | undefined {\n    if (typeof layerDef === 'string') {\n      return this._layers[layerDef] as LA;\n    }\n    return layerDef as LA;\n  }\n\n  /**\n   * Helper method to return added layer identificator by any definition type.\n   */\n  getLayerId(layerDef: LayerDef): string | undefined {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      if (layer.id) {\n        return layer?.id;\n      }\n      if (layer && layer.options) {\n        return layer.options.id;\n      }\n    }\n    throw new Error('No id for layer');\n  }\n\n  /**\n   * Return array of all added layer identifications.\n   */\n  getLayers(): string[] {\n    return Object.keys(this._layers);\n  }\n\n  // TODO: rename to getLayers, getLayers rename to getLayersIds\n  allLayers(): AddedLayers<M, L> {\n    return this._layers;\n  }\n\n  orderedLayers<LA extends LayerAdapter<M, L> = LayerAdapter<M, L>>(): LA[] {\n    return Object.values(this._layers).sort((a, b) =>\n      a.order && b.order ? a.order - b.order : 0,\n    ) as LA[];\n  }\n\n  findLayer<T extends LayerAdapter = LayerAdapter>(\n    filter: (adapter: T) => boolean,\n  ): T | undefined {\n    for (const l in this._layers) {\n      const layerAdapter = this._layers[l] as T;\n      const isFit = filter(layerAdapter);\n      if (isFit) {\n        return layerAdapter;\n      }\n    }\n  }\n\n  /**\n   * Check if the given layer on the map\n   */\n  isLayerVisible(layerDef: LayerDef): boolean {\n    const layer = this.getLayer(layerDef);\n    return layer && layer.options.visibility !== undefined\n      ? layer.options.visibility\n      : false;\n  }\n\n  /**\n   * Shortcut method to create base layer\n   */\n  async addBaseLayer<\n    K extends keyof LayerAdapters,\n    O extends AdapterOptions = AdapterOptions,\n  >(\n    adapter: K | Type<LayerAdapters[K]>,\n    options?: O | LayerAdaptersOptions[K],\n  ): Promise<LayerAdapter> {\n    const layer = await this.addLayer(\n      adapter,\n      {\n        ...options,\n        baselayer: true,\n      },\n      undefined,\n    );\n\n    return layer;\n  }\n\n  /**\n   * Registration of map layer.\n   *\n   * @param adapter - The name of layer adapter from [MapAdapter.layerAdapters](webmap#MapAdapter.layerAdapters).\n   *                May be custom object or class implemented by [MainLayerAdapter](webmap#MainLayerAdapter).\n   * @param options - Specific options for given adapter\n   *\n   * @example\n   * ```javascript\n   * webMap.addLayer('TILE', options).then((layer) => webMap.showLayer(layer));\n   *\n   * webMap.addLayer(CustomLayerAdapter, options);\n   * ```\n   */\n  async addLayer<\n    K extends keyof LayerAdapters,\n    LO extends AdapterOptions = AdapterOptions,\n  >(\n    adapter: LayerAdapterDefinition<K>,\n    options: LO | LayerAdaptersOptions[K] = {},\n    order?: number,\n  ): Promise<LayerAdapter> {\n    const id = this._layersIdCounter++;\n    const _order = defined(order)\n      ? order\n      : options.order !== undefined\n      ? options.order\n      : this.reserveOrder();\n    let adapterEngine: Type<LayerAdapter<M, L, LO>> | undefined;\n    if (typeof adapter === 'string') {\n      adapterEngine = this.getLayerAdapter(adapter) as Type<\n        LayerAdapter<M, L, LO>\n      >;\n    } else if (typeof adapter === 'function') {\n      adapterEngine = adapter as Type<LayerAdapter<M, L, LO>>;\n    } else if (\n      'then' in (adapter as Promise<Type<LayerAdapters[K]> | undefined>)\n    ) {\n      adapterEngine = (await adapter) as Type<LayerAdapter<M, L, LO>>;\n    }\n\n    const geoJsonOptions = options as GeoJsonAdapterOptions;\n\n    this._updateGeoJsonOptions(geoJsonOptions);\n\n    options = {\n      id: String(id),\n      order: _order,\n      ...options,\n    };\n\n    // options.visibility is a layer global state\n    const visibility = options.visibility ?? true;\n    options.visibility = false;\n\n    if (options.baselayer) {\n      options.order = 0;\n    }\n    if (this.options.onBeforeAddLayer) {\n      const modified = this.options.onBeforeAddLayer({\n        options,\n        adapter: adapterEngine,\n      });\n      if (modified) {\n        if (modified.options) {\n          options = modified.options;\n        }\n        if (modified.adapter) {\n          adapterEngine = modified.adapter as Type<LayerAdapter<M, L, LO>>;\n        }\n      }\n    }\n    if (adapterEngine !== undefined) {\n      const _adapter = new adapterEngine(this.mapAdapter.map, options);\n      _adapter.options = { ...options, ..._adapter.options };\n\n      if (_adapter.options.baselayer) {\n        options.baselayer = true;\n        options.order = 0;\n        _adapter.options.order = 0;\n      }\n\n      let layerId: string | undefined;\n      if (_adapter.options.id) {\n        layerId = String(_adapter.options.id);\n\n        this._layers[layerId] = _adapter;\n      }\n      this._emitLayerEvent('layer:preadd', layerId || '', _adapter);\n      await this.onMapLoad();\n      _adapter.map = this.mapAdapter.map;\n      const layer = await _adapter.addLayer(_adapter.options);\n      // checking that the original layer was inserted into the adapter anyway\n      _adapter.layer = layer;\n      // think about how to move `id` to the adapter's constructor,\n      // but that it is not required in the options\n      _adapter.id = _adapter.options.id || String(id);\n      _adapter.options.id = _adapter.id;\n      if (options.baselayer) {\n        _adapter.options.order = 0;\n      }\n      _adapter.order = _adapter.options.order ?? _order;\n      if (layerId) {\n        delete this._layers[layerId];\n      }\n      layerId = String(_adapter.id);\n      if (this._layers[layerId]) {\n        throw Error(`layer with id '${layerId}' already exist`);\n      }\n      if (layerId) {\n        this._layers[layerId] = _adapter;\n\n        if (geoJsonOptions.filter) {\n          this.filterLayer(_adapter, geoJsonOptions.filter);\n        }\n        if (options.baselayer) {\n          this._baselayers.push(layerId);\n        }\n\n        if (visibility) {\n          await this.showLayer(layerId);\n        }\n      }\n      const opacity = options.opacity;\n      if (opacity !== undefined && opacity <= 1) {\n        this.setLayerOpacity(_adapter, opacity);\n      }\n      // TODO: remove backward compatibility for `getExtent`\n      const getBounds = layer && (_adapter.getBounds || _adapter.getExtent);\n      if (options.fit && getBounds) {\n        const extent = await getBounds.call(_adapter);\n        if (extent) {\n          await this.fitBounds(extent);\n        }\n      }\n      if (options.onAdded) {\n        options.onAdded(_adapter);\n      }\n      this._emitLayerEvent('layer:add', layerId, _adapter);\n      return _adapter;\n    }\n    return Promise.reject('No adapter');\n  }\n\n  async addLayerFromAsyncAdapter<\n    K extends keyof LayerAdapters,\n    O extends AdapterOptions = AdapterOptions,\n  >(\n    adapter: AdapterConstructor,\n    options: O | LayerAdaptersOptions[K],\n    order?: number,\n  ): Promise<LayerAdapter> {\n    const _order =\n      order || options.order !== undefined\n        ? options.order\n        : 0 || this.reserveOrder();\n    const adapterConstructor = adapter as AdapterConstructor;\n    const adapterConstructorPromise = adapterConstructor();\n    const adapterEngine = await adapterConstructorPromise;\n    if (adapterEngine) {\n      return this.addLayer(adapterEngine, options, _order);\n    }\n    return Promise.reject('No adapter');\n  }\n\n  /**\n   * Remove all layer from map and memory.\n   */\n  removeLayers(\n    allowCb?: (layer: string, adapter: LayerAdapter) => boolean,\n  ): void {\n    for (const l in this._layers) {\n      let allow = true;\n      if (allowCb) {\n        allow = allowCb(l, this._layers[l]);\n      }\n      if (allow) {\n        this.removeLayer(l);\n        delete this._layers[l];\n      }\n    }\n  }\n\n  reserveOrder(): number {\n    return this._layersOrderCounter++;\n  }\n\n  /**\n   * Remove all layers but not remove basemap.\n   */\n  removeOverlays(): void {\n    this.removeLayers((layerId, layer) => {\n      if (layer && layer.options && layer.options.baselayer) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Remove specific layer from map and memory by its definition.\n   */\n  removeLayer(layerDef: LayerDef): void {\n    const layer = this.getLayer(layerDef);\n    const layerId = layer && this.getLayerId(layer);\n    if (layer && layerId) {\n      this.emitter.emit('layer:preremove', layer);\n      if (layer.beforeRemove) {\n        layer.beforeRemove();\n      }\n      if (layer.removeLayer) {\n        layer.removeLayer();\n      } else {\n        this.mapAdapter.removeLayer(layer.layer);\n      }\n      if (layer.options && layer.options.baselayer) {\n        const index = this._baselayers.indexOf(layerId);\n        if (index) {\n          this._baselayers.splice(index, 1);\n        }\n      }\n      delete this._layers[layerId];\n      this.emitter.emit('layer:remove', layer);\n    }\n  }\n\n  /**\n   * Create layer from GeoJson data. Set style and behavior for selection.\n   *\n   * @example\n   * ```javascript\n   * // Add simple layer\n   * webMap.addGeoJsonLayer({ data: geojson, paint: { color: 'red' } });\n   *\n   * // Add styled by feature property layer with selection behavior\n   * webMap.addGeoJsonLayer({\n   *   data: geojson,\n   *   paint: function (feature) {\n   *     return { color: feature.properties.color, opacity: 0.5 }\n   *   },\n   *  selectedPaint: function (feature) {\n   *    return { color: feature.properties.selcolor, opacity: 1 }\n   *  },\n   *  selectable: true,\n   *  multiselect: true\n   * });\n   *\n   * // Add marker layer styled with use [Icons](icons)\n   * webMap.addGeoJsonLayer({ data: geojson, paint: webMap.getIcon({ color: 'orange' })});\n   *\n   * // work with added layer\n   * const layer = webMap.addGeoJsonLayer({ data: geojson, id: 'my_layer_name'});\n   * // access layer by id\n   * webMap.showLayer('my_layer_name');\n   * // or access layer by instance\n   * webMap.showLayer(layer);\n   * ```\n   */\n  addGeoJsonLayer<\n    K extends keyof LayerAdapters = keyof LayerAdapters,\n    O extends GeoJsonAdapterOptions<any, any> = GeoJsonAdapterOptions,\n  >(\n    opt: O = {} as O,\n    adapter?: LayerAdapterDefinition<K>,\n  ): Promise<VectorLayerAdapter<any, any, any>> {\n    opt = opt || ({} as O);\n    opt.multiselect = opt.multiselect !== undefined ? opt.multiselect : false;\n    opt.unselectOnSecondClick =\n      opt.unselectOnSecondClick !== undefined\n        ? opt.unselectOnSecondClick\n        : true;\n    if (!adapter) {\n      opt = updateGeoJsonAdapterOptions(opt);\n    }\n    opt.paint = opt.paint || {};\n    return this.addLayer(adapter || 'GEOJSON', opt);\n  }\n\n  /** Shortcut for {@link WebMapLayers.addGeoJsonLayer} to create GeoJson adapter with generic types for working in typescript */\n  addFeatureLayer<\n    P extends FeatureProperties = FeatureProperties,\n    G extends Geometry = Geometry,\n    O extends GeoJsonAdapterOptions<Feature<G, P>> = GeoJsonAdapterOptions<\n      Feature<G, P>\n    >,\n  >(options = {} as O): Promise<FeatureLayerAdapter<P, G>> {\n    return this.addGeoJsonLayer<'GEOJSON', O>(options) as Promise<\n      FeatureLayerAdapter<P, G>\n    >;\n  }\n\n  /** Shortcut for {@link WebMapLayers.addLayer} to create TileLayer adapter */\n  addTileLayer(\n    url: string,\n    options: Omit<TileAdapterOptions, 'url'> = {},\n  ): Promise<MainLayerAdapter<M, L, TileAdapterOptions>> {\n    return this.addLayer('TILE', { ...options, url }) as Promise<\n      MainLayerAdapter<M, L, TileAdapterOptions>\n    >;\n  }\n\n  /** Shortcut for {@link WebMapLayers.addLayer} to create TileLayer adapter */\n  addImageLayer(\n    url: string,\n    options: Omit<ImageAdapterOptions, 'url'>,\n  ): Promise<MainLayerAdapter<M, L, ImageAdapterOptions>>;\n  addImageLayer(\n    options: ImageAdapterOptions,\n  ): Promise<MainLayerAdapter<M, L, ImageAdapterOptions>>;\n  addImageLayer(\n    urlOrOptions: string | ImageAdapterOptions,\n    options?: Omit<ImageAdapterOptions, 'url'>,\n  ): Promise<MainLayerAdapter<M, L, ImageAdapterOptions>> {\n    let url;\n    if (typeof urlOrOptions === 'string') {\n      url = urlOrOptions;\n    } else {\n      url = urlOrOptions.url;\n      options = urlOrOptions;\n    }\n\n    return this.addLayer('IMAGE', { ...options, url }) as Promise<\n      MainLayerAdapter<M, L, ImageAdapterOptions>\n    >;\n  }\n\n  /**\n   * Show added layer on the map by it definition.\n   */\n  showLayer(\n    layerDef: LayerDef,\n    options: ToggleLayerOptions = {},\n  ): Promise<void> {\n    return this.toggleLayer(layerDef, true, options);\n  }\n\n  /**\n   * Hide added layer on the map by it definition.\n   */\n  hideLayer(\n    layerDef: LayerDef,\n    options: ToggleLayerOptions = {},\n  ): Promise<void> {\n    return this.toggleLayer(layerDef, false, options);\n  }\n\n  /**\n   * Change added layer visibility on the map by given status or inverse current status.\n   *\n   * @example\n   * ```javascript\n   * webMap.addLayer('TILE', {id: 'my_layer', url: ''}).then((layer) => {\n   *   webMap.toggleLayer(layer, true);\n   *   webMap.toggleLayer('my_layer', false);\n   *   webMap.toggleLayer('my_layer');\n   *   webMap.isLayerVisible(layer); // true\n   * });\n   * ```\n   */\n  toggleLayer(\n    layerDef: LayerDef,\n    status?: boolean,\n    options: ToggleLayerOptions = {},\n  ): Promise<void> {\n    const layer = this.getLayer(layerDef);\n\n    const onMap = layer && layer.options.visibility;\n    const toStatus = status !== undefined ? status : !onMap;\n    const silent = options.silent !== undefined ? options.silent : false;\n    const action = async (l: LayerAdapter) => {\n      const id = String(l.id);\n      const preEventName = toStatus ? 'layer:preshow' : 'layer:prehide';\n      const eventName = toStatus ? 'layer:show' : 'layer:hide';\n      if (!silent) {\n        this._emitLayerEvent(preEventName, id, l);\n        this._emitLayerEvent('layer:pretoggle', id, l);\n      }\n      if (toStatus && this.mapAdapter) {\n        const order = l.options.baselayer ? 0 : l.options.order;\n\n        // do not show baselayer if another on the map\n        if (l.options.baselayer && this._baselayers.length) {\n          const anotherVisibleBaselayers = this._baselayers.filter((x) => {\n            return x !== l.id && this.isLayerVisible(x);\n          });\n          for (const bl of anotherVisibleBaselayers) {\n            await this.hideLayer(bl);\n          }\n        }\n        if (l.showLayer) {\n          await l.showLayer.call(l, l.layer);\n        } else if (l.layer !== undefined) {\n          await this.mapAdapter.showLayer(l.layer);\n        }\n        if (order !== undefined) {\n          this.mapAdapter.setLayerOrder(l.layer, order, this._layers);\n        }\n      } else {\n        if (l.hideLayer) {\n          await l.hideLayer.call(l, l.layer);\n        } else if (l.layer !== undefined) {\n          await this.mapAdapter.hideLayer(l.layer);\n        }\n      }\n      l.options.visibility = toStatus;\n      if (!silent) {\n        this._emitLayerEvent(eventName, id, l);\n        this._emitLayerEvent('layer:toggle', id, l);\n      }\n    };\n    if (layer && layer.options.visibility !== toStatus) {\n      return this.onMapLoad().then(() => action(layer));\n    }\n    return Promise.resolve();\n  }\n\n  updateLayer(layerDef: LayerDef): Promise<void> {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      if (layer.updateLayer) {\n        return Promise.resolve(layer.updateLayer());\n      } else if (this.isLayerVisible(layer)) {\n        return this.hideLayer(layer, { silent: true }).then(() => {\n          return this.showLayer(layer, { silent: true });\n        });\n      }\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * Set transparency for a given layer by number from 0 to 1\n   */\n  setLayerOpacity(layerDef: LayerDef, value: number): void {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      if (layer.setOpacity) {\n        layer.setOpacity(value);\n      } else if (this.mapAdapter.setLayerOpacity) {\n        this.mapAdapter.setLayerOpacity(layer.layer, value);\n      }\n    }\n  }\n\n  // requestGeomString(pixel: Pixel, pixelRadius: number) {\n  //   if (this.mapAdapter.requestGeomString) {\n  //     return this.mapAdapter.requestGeomString(pixel, pixelRadius);\n  //   }\n  // }\n\n  /**\n   * Mark the layer as selected.\n   * If the adapter is a vector layer and supports data selection,\n   * you can pass a callback function to specify which data will be selected.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {\n   *   webMap.selectLayer(layer, ({feature}) => feature.id === '42');\n   * });\n   * ```\n\n   */\n  selectLayer(layerDef: LayerDef, findFeatureFun?: DataLayerFilter): void {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      const adapter = layer as VectorLayerAdapter;\n      if (adapter && adapter.select) {\n        adapter.select(findFeatureFun);\n      }\n      const layerId = this.getLayerId(layer);\n      if (layerId) {\n        this._selectedLayers.push(layerId);\n      }\n    }\n  }\n\n  /**\n   * Unselect the given layer.\n   * If the adapter is a vector layer and supports data selection,\n   * you can pass a callback function to specify which data will be unselected.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {\n   *   webMap.unSelectLayer(layer, ({feature}) => feature.id === '42');\n   * });\n   * ```\n   *\n   */\n  unSelectLayer(layerDef: LayerDef, findFeatureFun?: DataLayerFilter): void {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      const adapter = layer && (layer as VectorLayerAdapter);\n      if (adapter.unselect) {\n        adapter.unselect(findFeatureFun);\n      }\n      const layerId = this.getLayerId(layer);\n      if (layerId) {\n        const index = this._selectedLayers.indexOf(layerId);\n        if (index !== -1) {\n          this._selectedLayers.splice(index, 1);\n        }\n      }\n    }\n  }\n  /** Remove selection from any selected selectable layer */\n  unSelectLayers(): void {\n    const layers = Object.values(this.allLayers());\n    let l: VectorLayerAdapter;\n    for (l of layers) {\n      if (l.unselect) {\n        l.unselect();\n      }\n    }\n  }\n\n  /**\n   * Hide features from a vector layer using a callback function.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {\n   *   webMap.filterLayer(layer, ({feature}) => feature.id === '42');\n   * });\n   * ```\n   *\n   */\n  filterLayer(\n    layerDef: LayerDef,\n    filter: DataLayerFilter<Feature, L>,\n  ): LayerDefinition<Feature, L>[] {\n    const layer = this.getLayer(layerDef);\n    const adapter = layer as VectorLayerAdapter;\n    if (adapter.filter) {\n      return adapter.filter(filter);\n    }\n    return [];\n  }\n\n  propertiesFilter(\n    layerDef: LayerDef,\n    filters: PropertiesFilter,\n    options?: FilterOptions,\n  ): void {\n    const layer = this.getLayer(layerDef);\n    if (!layer) return;\n    const adapter = layer as VectorLayerAdapter;\n    if (adapter.propertiesFilter) {\n      adapter.propertiesFilter(filters, options);\n    } else if (adapter.filter) {\n      this.filterLayer(adapter, (e) => {\n        if (e.feature && e.feature.properties) {\n          return propertiesFilter(e.feature.properties, filters);\n        }\n        return true;\n      });\n    }\n  }\n\n  removeLayerFilter(layerDef: LayerDef): void {\n    const layer = this.getLayer(layerDef);\n    const adapter = layer as VectorLayerAdapter;\n    if (adapter.removeFilter) {\n      adapter.removeFilter();\n    } else if (adapter.filter) {\n      adapter.filter(() => {\n        return true;\n      });\n    }\n  }\n\n  /**\n   * Sets the GeoJSON data for given vector layer.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON').then((layer) => {\n   *   webMap.setLayerData(layer, geojson);\n   * });\n   * ```\n   */\n  setLayerData(layerDef: LayerDef, data: GeoJsonObject): void | Promise<void> {\n    const vectorAdapter = this.getLayer(layerDef);\n    const adapter = vectorAdapter as VectorLayerAdapter;\n    if (adapter) {\n      if (adapter.setData) {\n        return adapter.setData(data);\n      } else if (adapter.clearLayer && adapter.addData) {\n        adapter.clearLayer();\n        return adapter.addData(data);\n      }\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * Push new the GeoJSON features into given vector layer.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON', {data: geojson_features_5}).then((layer) => {\n   *   console.log(layer.getLayers().length) // > 5;\n   *   webMap.addLayerData(layer, geojson_features_3);\n   *   console.log(layer.getLayers().length) // > 8;\n   * });\n   * ```\n   */\n  addLayerData(layerDef: LayerDef, data: GeoJsonObject): void {\n    const layerMem = this.getLayer(layerDef);\n    const adapter = layerMem as VectorLayerAdapter;\n    if (adapter.addData) {\n      adapter.addData(data);\n    }\n  }\n\n  /**\n   * Remove from vector layer all features.\n   * it is possible to remove only some objects if you specify a callback function.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {\n   *   webMap.clearLayerData(layer, (feture) => feture.id === 42);\n   *   webMap.clearLayerData(layer);\n   * });\n   * ```\n   */\n  clearLayerData(layerDef: LayerDef, cb?: (feature: Feature) => boolean): void {\n    const layerMem = this.getLayer(layerDef);\n    const adapter = layerMem as VectorLayerAdapter;\n    if (adapter && adapter.clearLayer) {\n      adapter.clearLayer(cb);\n    }\n  }\n\n  setLayerPaint(layerDef: LayerDef, paint?: Paint | null): void {\n    const layer = this.getLayer(layerDef);\n    if (paint && layer && layer.setPaint) {\n      layer.setPaint(paint);\n    }\n  }\n  setLayerSelectedPaint(layerDef: LayerDef, paint?: Paint | null): void {\n    const layer = this.getLayer(layerDef);\n    if (paint && layer && layer.setSelectedPaint) {\n      layer.setSelectedPaint(paint);\n    }\n  }\n  updateLayerPaint(layerDef: LayerDef, paint: Partial<Paint>): void {\n    const layer = this.getLayer(layerDef);\n    if (paint && layer && layer.updatePaint) {\n      layer.updatePaint(paint);\n    }\n  }\n  updateLayerSelectedPaint(layerDef: LayerDef, paint: Partial<Paint>): void {\n    const layer = this.getLayer(layerDef);\n    if (paint && layer && layer.updateSelectedPaint) {\n      layer.updateSelectedPaint(paint);\n    }\n  }\n\n  getAttributions(options: GetAttributionsOptions): string[] {\n    const attributions: string[] = [];\n    for (const l in this._layers) {\n      const layerCache = this._layers[l];\n      const onlyVisible =\n        options.onlyVisible !== undefined ? options.onlyVisible : true;\n      let useLayerAttr = onlyVisible ? layerCache.options.visibility : true;\n      if (useLayerAttr && options.onlyBaselayer) {\n        useLayerAttr = this._baselayers.includes(l);\n      }\n      if (useLayerAttr) {\n        const attr = layerCache.options && layerCache.options.attribution;\n        if (attr) {\n          attributions.push(attr);\n        }\n      }\n    }\n\n    return attributions;\n  }\n\n  getActiveBaseLayer(): MainLayerAdapter<M, any, AdapterOptions> | undefined {\n    const visibleLayerBaseLayer = this.getBaseLayers().find((x) => {\n      return this.isLayerVisible(x);\n    });\n    if (visibleLayerBaseLayer) {\n      return this.getLayer(visibleLayerBaseLayer);\n    }\n  }\n\n  addTileJsonLayer(\n    tileJson: TileJson,\n  ): Promise<MainLayerAdapter<M, any, TileAdapterOptions>> {\n    // if (this.mapAdapter.createTileJsonlayer) {\n    // } else {\n\n    const url = tileJson.tiles[0];\n    return this.addLayer('TILE', {\n      url,\n      maxZoom: tileJson.maxzoom,\n      minZoom: tileJson.minzoom,\n      subdomains: tileJson.scheme,\n      attribution: tileJson.attribution,\n    }) as Promise<MainLayerAdapter<M, any, TileAdapterOptions>>;\n  }\n\n  /** @internal */\n  _emitLayerEvent(name: keyof E, id: string, options?: unknown) {\n    const name_ = String(name);\n    if (defined(id) && name_.startsWith('layer:')) {\n      const specificLayerName = name_.replace('layer:', 'layer-' + id + ':');\n      // @ts-ignore can't paste template literal key for interface\n      this.emitter.emit(specificLayerName, options);\n    }\n    // @ts-ignore\n    this.emitter.emit(name, options);\n  }\n\n  private async _onLayerClick(options: OnLayerMouseOptions) {\n    const id = options.layer.id;\n    this._emitLayerEvent('layer:click', id || '', options);\n    return Promise.resolve(options);\n  }\n\n  private async _onLayerSelect(options: OnLayerSelectOptions) {\n    this._emitLayerEvent('layer:select', options.layer.id || '', options);\n    return Promise.resolve(options);\n  }\n\n  private _updateGeoJsonOptions(options: GeoJsonAdapterOptions) {\n    const {\n      onSelect,\n      onLayerSelect,\n      onClick,\n      onLayerClick,\n      onMouseOut,\n      onMouseOver,\n    } = options;\n    const onLayerClickFromOpt = onClick || onLayerClick;\n    options.onClick = (e) => {\n      if (onLayerClickFromOpt) {\n        onLayerClickFromOpt(e);\n      }\n      return this._onLayerClick(e);\n    };\n\n    options.onMouseOut = (e) => {\n      const id = e.layer.id;\n      onMouseOut && onMouseOut(e);\n      if (defined(id)) {\n        this._emitLayerEvent(`layer:mouseout`, id, e);\n      }\n    };\n\n    options.onMouseOver = (e) => {\n      const id = e.layer.id;\n      onMouseOver && onMouseOver(e);\n      if (defined(id)) {\n        this._emitLayerEvent(`layer:mouseover`, id, e);\n      }\n    };\n\n    // TODO: remove backward compatibility for onLayerSelect\n    const onLayerSelectFromOpt = onSelect || onLayerSelect;\n    options.onSelect = (e) => {\n      if (onLayerSelectFromOpt) {\n        onLayerSelectFromOpt(e);\n      }\n      return this._onLayerSelect(e);\n    };\n\n    if (!options.nativePaint) {\n      if (this.options.paint) {\n        options.paint = preparePaint(\n          options.paint || {},\n          this.options.paint,\n          this.getPaintFunctions,\n        );\n      }\n      if (options.selectedPaint && this.options.selectedPaint) {\n        options.selectedPaint = preparePaint(\n          options.selectedPaint,\n          this.options.selectedPaint,\n          this.getPaintFunctions,\n        );\n      }\n    }\n  }\n}\n","import { WebMapLayers } from './WebMapLayers';\nimport { createToggleControl } from './components/controls/createToggleControl';\n\nimport type { WebMapMain } from './WebMapMain';\nimport type { MapOptions } from './interfaces/MapOptions';\nimport type { WebMapEvents } from './interfaces/Events';\nimport type {\n  MapControl,\n  CreateControlOptions,\n  ButtonControlOptions,\n  ToggleControlOptions,\n  ToggleControl,\n  MapControls,\n} from './interfaces/MapControl';\nimport type { ControlPosition } from './interfaces/MapAdapter';\n\n/**\n * Collection of methods for managing map controls\n */\nexport class WebMapControls<\n    M = any,\n    L = any,\n    C = any,\n    E extends WebMapEvents = WebMapEvents,\n    O extends MapOptions = MapOptions,\n  >\n  extends WebMapLayers<M, L, E, O>\n  implements WebMapLayers, WebMapMain\n{\n  static controls: {\n    [name: string]: (webMap: WebMapControls, options?: any) => any;\n  } = {\n    CONTROL: (\n      webMap: WebMapControls,\n      options: {\n        control: MapControl;\n        options?: CreateControlOptions;\n      },\n    ) => {\n      return webMap.createControl(options.control, options.options);\n    },\n    BUTTON: (webMap: WebMapControls, options: ButtonControlOptions) => {\n      return webMap.createButtonControl(options);\n    },\n    TOGGLE: (webMap: WebMapControls, options: ToggleControlOptions) => {\n      return webMap.createToggleControl(options);\n    },\n  };\n\n  private _loadControlQueue: {\n    [key in ControlPosition]: (() => Promise<any>)[];\n  } = {\n    'top-right': [],\n    'bottom-right': [],\n    'top-left': [],\n    'bottom-left': [],\n  };\n  private _isControlLoading: { [key in ControlPosition]: boolean } = {\n    'top-right': false,\n    'bottom-right': false,\n    'top-left': false,\n    'bottom-left': false,\n  };\n\n  async addControl<K extends keyof MapControls>(\n    controlDef: K | C,\n    position: ControlPosition,\n    options?: MapControls[K],\n  ): Promise<any> {\n    let control: C | undefined;\n    position = position ?? 'top-left';\n    if (typeof controlDef === 'string') {\n      control = this.getControl(controlDef, options);\n    } else {\n      control = controlDef as C;\n    }\n    if (control) {\n      return new Promise<() => Promise<any>>((resolve) => {\n        const promise = async () => {\n          const _control = await control;\n          const c = this.mapAdapter.addControl(_control, position);\n          resolve(c);\n        };\n        this._setControlQueue(position, promise);\n      });\n    }\n  }\n\n  /**\n   * Creating a universal map layout control element. Can be used with any map adapter.\n   *\n   * @example\n   * ```javascript\n   * const control = webMap.createControl({\n   *   onAdd() {\n   *     return document.createElement('div');\n   *   }\n   * });\n   * ```\n   */\n  async createControl(\n    control: MapControl,\n    options?: CreateControlOptions,\n  ): Promise<C | undefined> {\n    await this.onLoad('build-map');\n    if (this.mapAdapter.createControl) {\n      return this.mapAdapter.createControl(control, options);\n    }\n  }\n\n  async createButtonControl(\n    options: ButtonControlOptions,\n  ): Promise<C | undefined> {\n    await this.onLoad('build-map');\n    if (this.mapAdapter.createButtonControl) {\n      return this.mapAdapter.createButtonControl(options);\n    }\n  }\n\n  /**\n   * Create any toggler control button\n   * @param options - Options for control layout customization and assigning a callback function\n   *\n   * @example\n   * ```javascript\n   * const toggleControl = ngwMap.createToggleControl({\n   *   getStatus: () => webMap.isLayerVisible('any-layer-id'),\n   *   onClick: (status) => ngwMap.toggleLayer('webmap', status),\n   *   html: {\n   *     on: 'ON',\n   *     off: 'OFF'\n   *   },\n   *   title: 'Toggle layer visibility'\n   * });\n   * webMap.addControl(toggleControl, 'top-right');\n   * ```\n   * {@link http://code.nextgis.com/demo-examples-toggle-control | Toggle button control example}\n   */\n  async createToggleControl(\n    options: ToggleControlOptions,\n  ): Promise<(C & ToggleControl) | undefined> {\n    await this.onLoad('build-map');\n    if (this.mapAdapter.createToggleControl) {\n      return this.mapAdapter.createToggleControl(options);\n    } else {\n      if (this.mapAdapter.createButtonControl) {\n        return createToggleControl<C>(\n          this.mapAdapter.createButtonControl,\n          options,\n        );\n      }\n    }\n  }\n\n  /**\n   *\n   * @param control - Instance of WEB-GIS framework control.\n   *                  What is returned by the {@Link WebMapControls.createControl | create} method\n   */\n  removeControl(control: C): void {\n    if ('remove' in control) {\n      // @ts-ignore TODO: ugly code, rewrite\n      control.remove();\n    } else if (this.mapAdapter.removeControl) {\n      Promise.resolve(control).then((c) => {\n        this.mapAdapter.removeControl(c);\n      });\n    }\n  }\n\n  /**\n   * Get instance of registered control\n   * @param control - Any registered control string name\n   * @param options - Custom control options\n   */\n  getControl<K extends keyof MapControls>(\n    control: K,\n    options?: MapControls[K],\n  ): C | undefined {\n    const engine = this.mapAdapter.controlAdapters[control];\n    if (engine) {\n      return new engine(options);\n    } else {\n      const createFun = WebMapControls.controls[control];\n      if (createFun) {\n        return createFun(this, options);\n      }\n    }\n  }\n\n  getControlContainer(): HTMLElement | undefined {\n    if (this.mapAdapter.getControlContainer) {\n      return this.mapAdapter.getControlContainer();\n    }\n  }\n\n  private _setControlQueue(position: ControlPosition, cb: () => Promise<any>) {\n    this._loadControlQueue[position].push(cb);\n    if (!this._isControlLoading[position]) {\n      this._applyControls(position);\n    }\n  }\n\n  private async _applyControls(position: ControlPosition) {\n    if (this._loadControlQueue[position].length) {\n      this._isControlLoading[position] = true;\n      const controlCb = this._loadControlQueue[position][0];\n      await controlCb();\n      this._loadControlQueue[position].splice(0, 1);\n      this._applyControls(position);\n    } else {\n      this._isControlLoading[position] = false;\n    }\n  }\n}\n","import type {\n  ToggleControlOptions,\n  ToggleControl,\n  ButtonControlOptions,\n} from '../../interfaces/MapControl';\n\n/**\n * The toggle is a button with status.\n * @internal\n */\nexport function createToggleControl<C = any>(\n  createButtonControl: (options: ButtonControlOptions) => C,\n  options: ToggleControlOptions,\n): C & ToggleControl {\n  const link = document.createElement('div');\n\n  let status = false;\n  if (options.getStatus) {\n    status = options.getStatus();\n  } else if (options.status) {\n    status = options.status;\n  }\n\n  const title = options.title || '';\n  const html = options.html;\n\n  function setTitle() {\n    if (title) {\n      if (typeof title === 'string') {\n        link.title = title;\n      } else {\n        link.title = status ? title.on : title.off;\n      }\n      link.setAttribute('aria-label', link.title);\n    }\n  }\n  setTitle();\n\n  // DomEvent.disableClickPropagation(link);\n  // DomEvent.on(link, 'click', DomEvent.stop);\n\n  function _setHtml(htmlDef: string | HTMLElement) {\n    if (htmlDef instanceof HTMLElement) {\n      link.innerHTML = '';\n      link.appendChild(htmlDef);\n    } else if (typeof htmlDef === 'string') {\n      link.innerHTML = htmlDef;\n    }\n  }\n  function setHtml() {\n    if (html) {\n      if (typeof html === 'string' || html instanceof HTMLElement) {\n        _setHtml(html);\n      } else {\n        _setHtml(status ? html.on : html.off);\n      }\n      link.setAttribute('aria-label', link.title);\n    }\n  }\n  setHtml();\n\n  function _setClass(addClass: string, impact: boolean) {\n    addClass.split(' ').forEach((x) => {\n      if (impact) {\n        link.classList.add(x);\n      } else {\n        link.classList.remove(x);\n      }\n    });\n  }\n\n  function setClass() {\n    if (options.addClassOn) {\n      _setClass(options.addClassOn, status);\n    }\n    if (options.addClassOff) {\n      _setClass(options.addClassOff, !status);\n    }\n  }\n\n  if (options.addClass) {\n    _setClass(options.addClass, true);\n  }\n  setClass();\n\n  const changeStatus = (status_?: boolean) => {\n    if (status_ !== undefined) {\n      status = status_;\n    }\n    setHtml();\n    setTitle();\n    setClass();\n  };\n\n  const onClick = (status_?: boolean) => {\n    status = status_ !== undefined ? status_ : !status;\n    if (options.onClick) {\n      const afterClick = options.onClick(status);\n      Promise.resolve(afterClick)\n        .then(() => changeStatus())\n        .catch(() => (status = !status));\n    } else {\n      changeStatus();\n    }\n  };\n\n  const buttonControl = createButtonControl({\n    html: link,\n    onClick,\n  }) as C & ToggleControl;\n  buttonControl.onClick = onClick;\n  buttonControl.changeStatus = changeStatus;\n  return buttonControl;\n}\n","import type { WebMap } from './WebMap';\n\nconst WEB_MAP_CONTAINER: Record<number, any> = {};\n\nexport function getWebMap<T extends WebMap = WebMap>(id: number): T {\n  return WEB_MAP_CONTAINER[id];\n}\n\nexport function setWebMap(id: number, webMap: WebMap) {\n  WEB_MAP_CONTAINER[id] = webMap;\n}\n","/**\n * @privateRemarks\n * Since it was not possible to split the code through mixins, inheritance was used.\n * The `ts-mixin` plugin worked fine, but led to errors in IE.\n *\n * Now inheritance is as follow:\n * BaseWebMap \\> WebMapLayers \\> WebMap\n *\n * Will need to be done this way:\n * ```javascript\n * class WebMap extend mixin(WebMapLayers, WebMapControls) {}\n * ```\n *\n * This approach can also be considered\n * ```javascript\n * class WebMap {\n *   layers: WebMapLayers;\n *   controls  WebMapControls\n * }\n * ```\n * and then\n *\n * const webMap = new WebMap(...);\n * webMap.layers.addLayer(...)\n *\n * looks good, but will add difficulty in inheriting from WebMap\n *\n * old:\n * ```javascript\n * class NgwMap extends WebMap {\n *   addLayer(...) {\n *      super.addLayer(...)\n *   }\n * }\n * ```\n * new:\n * ```javascript\n * class NgwLayers extends WebMapLayers {\n *   addLayer(...) {\n *     super.addLayer(...)\n *   }\n * }\n *\n * class NgwMap extends WebMap {\n *   layersClass = NgwLayers\n * }\n * ```\n * ...and there will be compatibility issues\n */\n\nimport { WebMapMain } from './WebMapMain';\nimport { WebMapControls } from './WebMapControls';\n\nimport type { MapOptions } from './interfaces/MapOptions';\nimport type { ControlOptions } from './interfaces/MapControl';\nimport type { WebMapEvents } from './interfaces/Events';\nimport type { WebMapLayers } from './WebMapLayers';\nimport { getWebMap, setWebMap } from './container';\n\n/**\n * The core component for managing map adapters.\n * It contains methods for adding and manipulation with\n * {@link WebMapMain | map}, {@link WebMapLayers | layers} and {@link WebMapControls | controls}.\n *\n * @example\n * ```javascript\n * import { WebMap } from '@nextgis/webmap';\n * import MapAdapter from '@nextgis/ol-map-adapter';\n *\n * const webMap = new WebMap({\n *   mapAdapter: new MapAdapter(),\n *   target: 'map',\n * });\n * ```\n *\n * @typeParam M - Interactive Map used in the adapter\n * @typeParam L - Layer\n * @typeParam C - Control\n * @typeParam E - Events\n *\n */\nexport class WebMap<\n    M = any,\n    L = any,\n    C = any,\n    E extends WebMapEvents = WebMapEvents,\n    O extends MapOptions = MapOptions,\n  >\n  extends WebMapControls<M, L, C, E, O>\n  implements WebMapControls, WebMapLayers, WebMapMain\n{\n  constructor(mapOptions: O) {\n    super(mapOptions);\n    this._addControls();\n    setWebMap(this.id, this);\n  }\n\n  static get<T extends WebMap = WebMap>(id: number): T {\n    return getWebMap<T>(id);\n  }\n\n  /**\n   * @internal\n   */\n  protected async _addLayerProviders(): Promise<void> {\n    for await (const kit of this._starterKits) {\n      if (kit.getLayerAdapters) {\n        const adapters = await kit.getLayerAdapters.call(kit);\n        if (adapters) {\n          for await (const adapter of adapters) {\n            const newAdapter = await adapter.createAdapter(this);\n            if (newAdapter) {\n              this.mapAdapter.layerAdapters[adapter.name] = newAdapter;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected async _onLoadSync(): Promise<void> {\n    for await (const kit of this._starterKits) {\n      if (kit.onLoadSync) {\n        try {\n          await kit.onLoadSync.call(kit, this);\n        } catch (er) {\n          console.error(er);\n        }\n      }\n    }\n  }\n\n  private _addControls(): void {\n    if (this.options.controls) {\n      this.options.controls.forEach((x) => {\n        let controlAdapterName = x;\n        let controlOptions: ControlOptions = {};\n        if (typeof x === 'string' && this.options.controlsOptions) {\n          if (this.options.controlsOptions[x]) {\n            controlOptions = this.options.controlsOptions[x];\n            if (controlOptions.control !== undefined) {\n              controlAdapterName = controlOptions.control;\n            }\n          }\n        }\n        const { position, ...options } = controlOptions;\n        this.addControl(controlAdapterName, position || 'top-left', options);\n      });\n    }\n    this._emitStatusEvent('controls:create');\n  }\n}\n"],"names":["Dialog","constructor","options","template","closeBtn","closeBtnTemplate","this","_dialog","document","createElement","dialogs","push","className","_parent","parent","body","_isNativeDialog","showModal","dialogPolyfill","classList","add","_closeBtn","_createCloseBtn","_content","appendChild","updateContent","_addEventsListeners","forEach","x","destroy","getContainer","show","close","remove","content","_addContent","btn","addEventListener","e","stopPropagation","innerHTML","HTMLElement","preventDefault","openers","call","opener","onclick","canvg","require","er","getImageData","img","opt","canvas","window","context","getContext","Error","setAttribute","String","width","height","HTMLImageElement","drawImage","Canvg","fromString","start","getCoordinates","geojson","coordinates","cb","type","f","features","geometry","eachGeometry","geom","y","z","eachCoordinates","pos","getCentroid","feature","polylabel","arr","reduce","length","convertZoomLevel","zoom","convertMapClickEvent","evt","latLng","lngLat","lng","lat","point","pixel","top","left","allowedByType","line","polygon","typeAlias","Point","LineString","MultiPoint","Polygon","MultiLineString","MultiPolygon","GeometryCollection","typeAliasForFilter","backAliases","a","layerType","backAlias","findMostFrequentGeomType","counts","fry","maxName","c","maxCount","geometryFilter","backType","indexOf","getFeatureLngLatBounds","featureOrFeatures","bounds","LngLatBounds","Array","isArray","coord","extend","getFeatureBounds","ne","getNorthEast","sw","getSouthWest","createFeaturePositionOptions","getBounds","getCenter","getFeatureCenter","ID","operationsAliases","gt","lt","ge","le","eq","in","notin","like","ilike","reversOperations","PAINT","color","opacity","radius","mapboxTypeAlias","VectorAdapter","map","_layerId","beforeRemove","sourceId","getSource","removeSource","Object","assign","undefined","super","_sourceId","source","featureIdName","_selectionName","$onLayerMouseLeave","_onLayerMouseLeave","bind","$onLayerMouseMove","_onLayerMouseMove","_onMapClickLayers","layer","types","_types","paint","_beforeLayerLayer","t","geomType","_detectPaintType","_getLayerNameFromType","geomFilter","_addGeomLayer","_getNativeFilter","selectedPaint","selectionLayer","_getSelectionLayerNameFromType","selectedLayout","_onLayerAdd","propertiesFilter","filters","_filterProperties","_updatePropertiesFilter","removeFilter","_updateFilter","select","properties","_selectProperties","selected","onSelect","onLayerSelect","onSelect_","unselect","selectable","_removeAllPopup","layerId","removeLayer","index","splice","_removeEventListeners","setOpacity","val","Number","_updateLayerPaint","setPaint","setSelectedPaint","updatePaint","updateSelectedPaint","_onLayerClick","_getFeatureFromPoint","isSelected","_featureSelect","onClick","event","_createLayerOptions","alreadySelected","isFeatureSelected","becameSelected","unselectOnSecondClick","_unselectFeature","silent","_addUnselectCb","_selectFeature","popupOnSelect","_openPopup","popupOptions","refresh","_updateWithNativeFilter","filter","nativeFilter","name","layout","mType","layerOpt","id","visibility","_getAdditionalLayerOptions","nativeOptions","_addLayer","minZoom","maxZoom","minzoom","maxzoom","addLayer","Boolean","setFilter","layerName","layers","selName","mapboxType","_paint","nativePaint","typePaint","opacityProp","find","p","_createPaintForType","setLayoutProperty","setPaintProperty","isPaint","mapboxPaint","paint_","html","_registerImage","pathPaint","allowed","polyStroke","stroke","allowedType","paramName","prop","duration","isPaintCallback","_getFeatureFilterId","_featureFilterId","isIcon","hasImage","iconSize","image","svgStr","Promise","resolve","svgImage","Image","crossOrigin","src","btoa","onload","imageData","addImage","selLayerName","selectProperties","filterProperties","propertyFilters","_convertToMapboxFilter","_selectedFeatureIds","filters_","_operationsAliases","isPropertyFilter","field","operation","value","operationAlias","filterId","featureFilter","_openedPopup","openedPopup","setLngLat","popup","_closeHandlers","_removePopup","maxWidth","popupContent","createPopupContent","closeButton","selectOnHover","onClose","handler","str","makeHtmlFromString","popupOpt","closeOnClick","Popup","setDOMContent","addTo","unselectOnClose","once","_openLabel","labelField","closeOnMove","labelOnHover","text","setText","_closeLabel","_removeFeaturePopup","doNotUnselect","target","findIndex","closeHandlers","h","onMouseOver","features_","queryRenderedFeatures","o","getCanvas","style","cursor","onMouseOut","falsePaint","on","off","setupLayerTransformRequest","url","headers","transformRequests","url_","staticUrl","replace","TileAdapter","updateOpacity","l","tiles","subdomains","split","sourceOptions","tileSize","attribution","addSource","layerOptions","before","MvtAdapter","sources","includes","sourceLayer","OPTIONS","createControl","control","Control","getDefaultPosition","onAdd","element","bar","addClass","_container","onRemove","parentNode","removeChild","arrayToBoundsLike","fitBoundsOptions","MapboxglMapAdapter","EventEmitter","layerAdapters","controlAdapters","__setLayerOrder","debounce","_setLayerOrder","create","reject","mapOpt","version","container","attributionControl","fitOptions","mapAdapterOptions","center","Map","_requestManager","_transformRequestFn","console","warn","setTransformRequest","resourceType","_transformRequest","onMapLoaded","args","isLoaded","emitter","emit","loaded","setView","lngLatOrOpt","jumpTo","maxBounds","setMaxBounds","setZoom","setCenter","setMaxZoom","setMinZoom","fitBounds","getZoom","ar","toArray","linear","setRotation","angle","showLayer","layerIds","_toggleLayer","hideLayer","_map","setLayerOrder","order","setLayerOpacity","_onMapLoad","then","getLayer","createButtonControl","link","title","child","firstElementChild","lineHeight","offsetHeight","removeEventListener","addControl","position","removeControl","onMapClick","emitData","topFirst","sort","b","firstSelectedLayer","firstSelectedLayer_","unselectOnClick","_resolve","baseLayers","orderedLayers","baselayer","moveLayer","mem","_getLayerIds","_layers","getDependLayers","status","_onMapSourceData","data","dataType","isSourceLoaded","_onDataLoad","_onMapError","_sourceDataLoading","keys","tile","_unselectCb","r","params","_universalEvents","_positionEvents","TILE","WMS","bbox","format","service","request","srs","transparent","paramsStr","join","MVT","OSM","GEOJSON","clearLayer","_features","setData","detectedType","geometries","g","detectType","filterGeometries","fid","_filterFun","_filter","_updateLabels","getLayers","filtered","_filteredFeatureIds","_getFeatures","visible","fun","getSelected","selectedFeatureIds","allFeatures","_fireOnLayerSelectEvent","getExtent","sourceOpt","_opts","defineProperty","_sources","addData","_getPaintFromCallback","multiselect","selectionArray","filteredArray","selectFilter","filter_","_data","JSON","parse","ok","newFeatures","geomCollection","concat","toSave","defined","ZOOM","NavigationControl","showCompass","COMPASS","showZoom","ATTRIBUTION","AttributionControl","NetworkError","setPrototypeOf","prototype","message","location","origin","NgwError","loadData","callback","error","onCancel","method","xhr","XMLHttpRequest","open","responseType","getResponseText","responseText","processingResponse","forError","response","onerror","upload","onprogress","lengthComputable","percentComplete","total","onProgress","header","setRequestHeader","withCredentials","file","FormData","append","d","stringify","abort","send","templateRe","s","key","ResourceNotFoundError","obj","InsufficientPermissionsError","CONNECTORS","addConnector","connector","isObject","toString","exclude","resourceToQuery","resource","prefix","query","entries","children","parent_id","ResourcesControl","Cache","getOne","requestOptions","cache","forCache","keyname","addFull","_fetchResourceBy","_fetchResourceById","CancelablePromise","getOneOrFail","res","getId","getIdOrFail","resp","getMany","_resourceCacheFilter","items","get","serialization","resources","getParent","getChildrenOf","_getChildrenOf","_items","recursivePromises","item","recursive","update","put","delete","_cleanResourceItemCache","all","toDelete","cid","catch","matchAll","res1","res2","objectDeepEqual","NgwConnector","exist","baseUrl","auth","findConnector","route","routeStr","setNgw","logout","connect","makeQuery","login","password","getUserInfo","credentials","removeConnector","user","clean","getAuthorizationHeaders","client","makeClientId","Authorization","unescape","encodeURIComponent","req","activeRequests","cancel","getActiveApiRequests","apiRequest","params_","objectRemoveEmpty","makeApiRequest","apiItems","apiItem","shift","replaceParams","arg","paramArray","paramList","post","patch","fixUrlStr","_loadData","encodeURI","getResource","getResourceOrFail","getResourceBy","getResourceByKeyname","getResourceById","getResourceId","getResourceIdOrFail","getResourcesBy","getResourceParent","getResourceChildren","updateResource","deleteResource","_cleanActiveRequests","httpError","_handleHttpError","signal","activeRequestIndex","exception","expressions","match","lookup","cases","property","featureExpression","defValue","expression","expressionFun","createPropertyExpressionCb","excludeExpressionList","preparePaint","defaultPaint","getPaintFunctions","newPaint","getPaintFunction","getPaint","isPropertiesPaint","propertiesPaint","mask","paintsFilters","createPropertiesPaint","from","updatePaintOptionFromCallback","expressionCallback","withExpression","p_","fromCb","createExpressionCallback","expressionPaintCb","fill","strokeColor","strokeOpacity","fillColor","fillOpacity","iLike","toUpperCase","re","RegExp","exec","pf","$id","logic","filterFunction","operationExec","value_","cleanField","some","every","mixinProperties","derivedCtor","baseCtor","descriptor","getOwnPropertyDescriptor","alias","tms","updateQmsOptions","qms","protocol","serviceUrl","y_origin_top","copyright_text","z_max","z_min","loadJson","xmlHttp","onreadystatechange","readyState","getSubdomainsOriginUrl","originUrl","submodules","m","group","URL","createQmsAdapter","webMap","createOpt","QmsAdapter","qmsId","WebMapAdapter","mapAdapter","origin_url","QmsKit","getLayerAdapters","createAdapter","webmap","_createAdapter","href","decodeURIComponent","_params","set","search","urlComponent","state","_pushState","sourceUrl","param","paramsArr","rtn","queryString","i","history","replaceState","arrayUnique","elem","timeoutId","wait","wrapper","clear","setTimeout","apply","clearTimeout","full","Events","setEventStatus","_eventsStatus","onLoad","promises","getEventStatus","_eventName","isEqual","Date","Function","keysO","keysP","newObj","numberWithSpaces","parts","count","paintTypeAlias","deepmerge","mergeArray","target_","src_","array","dst","getBoundsCoordinates","westNorth","KeyCodes","StateItem","setValue","getValue","CenterState","toFixed","ZoomState","Math","round","weight","WebMapMain","mapOptions","_starterKits","starterKits","runtimeParams","tileJson","_setTileJsonOptions","_setInitMapState","mapState","_setupMap","_emitStatusEvent","setRuntimeParams","member","clearObject","getState","_mapState","getRuntimeParams","getElementById","setCursor","getCursor","getBoundsPolygon","zoomIn","toZoom","zoomOut","viewOpt","onMapLoad","getLayerAdapter","locate","events","stop","stopGetCoordFromMapClick","_coordFromMapClickPromise","getCoordFromMapClick","include","onCancel_","ev","deprecatedMapClick","eventName","_zoomToInitialExtent","_addLayerProviders","_onLoadSync","_extent","states","X","_initMapState","configurable","enumerable","_mapEvents","mapStatusEvent","mapEvent","removeListener","_windowOnFocus","windowOnFocus","_keysPressed","keysPressed","_keysReleased","keysReleased","addKeyboardEventsListener","pressed","keyName","code","keyCodeAlias","removeKeyboardEventsListener","keyCode","WebMapLayers","addTileJsonLayer","layerDef","extent","isBaseLayer","_baselayers","getBaseLayers","baselayers","getBaseLayersIds","getLayerId","allLayers","values","findLayer","layerAdapter","isLayerVisible","adapter","_layersIdCounter","_order","reserveOrder","adapterEngine","geoJsonOptions","_updateGeoJsonOptions","onBeforeAddLayer","modified","_adapter","_emitLayerEvent","filterLayer","fit","onAdded","adapterConstructorPromise","removeLayers","allowCb","allow","_layersOrderCounter","removeOverlays","addGeoJsonLayer","detectGeometryType","updateGeoJsonAdapterOptions","addFeatureLayer","addTileLayer","addImageLayer","urlOrOptions","toggleLayer","onMap","toStatus","action","async","preEventName","anotherVisibleBaselayers","bl","updateLayer","selectLayer","findFeatureFun","_selectedLayers","unSelectLayer","unSelectLayers","removeLayerFilter","setLayerData","addLayerData","clearLayerData","setLayerPaint","setLayerSelectedPaint","updateLayerPaint","updateLayerSelectedPaint","getAttributions","attributions","layerCache","useLayerAttr","onlyVisible","onlyBaselayer","attr","getActiveBaseLayer","visibleLayerBaseLayer","scheme","name_","startsWith","specificLayerName","onLayerClick","onLayerClickFromOpt","onLayerSelectFromOpt","_onLayerSelect","WebMapControls","controlDef","getControl","_setControlQueue","_control","createToggleControl","getStatus","setTitle","_setHtml","htmlDef","setHtml","_setClass","impact","setClass","addClassOn","addClassOff","changeStatus","status_","afterClick","buttonControl","engine","createFun","controls","getControlContainer","_loadControlQueue","_isControlLoading","_applyControls","controlCb","CONTROL","BUTTON","TOGGLE","WEB_MAP_CONTAINER","WebMap","_addControls","getWebMap","kit","adapters","newAdapter","onLoadSync","controlAdapterName","controlOptions","controlsOptions"],"sourceRoot":""}